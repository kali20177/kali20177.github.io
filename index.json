[{"categories":null,"content":"火焰图 使用 Linux 的性能分析器 perf 采集性能数据。 sudo apt-get install linux-tools-common linux-tools-generic linux-tools-`uname -r` 查找需要监视的程序 PID 号，并使用 perf 记录： # 获取程序进程号 ps aux | grep XXX # 监视性能，每秒 99 次，持续 120 秒 sudo perf record -F 99 -p PID_NUM -g -- sleep 120 执行后会在当前目录下产生 perf.data 文件，无需等待被监视程序结束，perf 被中断也能生成结果文件。进一步和处理结果： perf script \u003e out.perf 默认情况下使用 perf 需要 sudo 权限，通过下列设置修改执行权限： # 允许非特权用户进行内核分析和访问 CPU 事件 echo 0 | sudo tee /proc/sys/kernel/perf_event_paranoid sudo sh -c 'echo kernel.perf_event_paranoid=0 \u003e\u003e /etc/sysctl.d/local.conf' # 启用内核模块符号解析以供非特权用户使用 echo 0 | sudo tee /proc/sys/kernel/kptr_restrict sudo sh -c 'echo kernel.kptr_restrict=0 \u003e\u003e /etc/sysctl.d/local.conf' 需要使用项目FlameGraph 中的 perl 脚本生成 svg 文件，可视化性能数据。 # On-CPU CPU 火焰图 ./stackcollapse-perf.pl out.perf \u003e out.folded # 或者 Off-CPU IO 火焰图 ./stackcollapse.pl out.perf \u003e out.folded 生成 svg 图像： ./flamegraph.pl out.folded \u003e result.svg 对于两次采集的不同数据，可以使用 difffolded.pl 生成差异火焰图。 ./difffolded.pl out1.folded out2.folded | ./flamegraph.pl \u003e diff.svg 浏览器打开可以进行交互。 火焰图纵向深度表示调用栈的深度，自底向上。横向表示抽象数，如果一个函数越宽，代表采样时被命中的次数越多，该函数在程序实际执行时间越长。 如果顶层函数存在平顶，表示该函数可能存在性能瓶颈。 ","date":"2024-06-20","objectID":"/draft/%E7%99%BE%E7%A7%91/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:1:0","tags":null,"title":"性能分析","uri":"/draft/%E7%99%BE%E7%A7%91/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"参考 Linux Perf 如何读懂火焰图？ 火焰图性能分析 ","date":"2024-06-20","objectID":"/draft/%E7%99%BE%E7%A7%91/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:2:0","tags":null,"title":"性能分析","uri":"/draft/%E7%99%BE%E7%A7%91/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"普通链表（非侵入式） 由数据域和 link 域组成。 单向： struct list_element { void *data; // data 域 struct list_element * next; // link 域 }; 双向： struct list_element { void *data; struct list_element * prev; struct list_element * next; }; 环形： 末尾元素指向开头，Linux 内核标准链表采用双向环形链表，但是不使用非侵入式实现。 非侵入式链表在一条链表上元素类型必须相同，泛化能力差。 ","date":"2024-05-25","objectID":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/:1:0","tags":null,"title":"链表","uri":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"侵入式链表 (intrusive linked lists) 丢弃 data 域： struct list_head { struct list_element * prev; struct list_element * next; }; 将 list_head 嵌入要操作的数据结构中： struct ListNodeInt { list_head link; int data; } struct ListNodeDouble { list_head link; double data; } 因此侵入式链表节点类型不需要一致，使用时需要使用者自己转型。 使用宏 container_of() 寻找从链表指针到父结构的变量，在 C 中，结构的偏移在编译时被 ABI 固定。 #define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-\u003emember ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offset_of(type,member) );}) 通过 container_of() 宏返回包含 list_head 父类型结构体。 #define list_entry(ptr, type, member) \\ container_of(ptr, type, member) 例子： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e // 定义 list_head 结构体 struct list_head { struct list_head *next, *prev; }; // 初始化链表头宏 #define INIT_LIST_HEAD(ptr) do { \\ (ptr)-\u003enext = (ptr); (ptr)-\u003eprev = (ptr); \\ } while (0) // 添加节点的内部函数 static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next) { next-\u003eprev = new; new-\u003enext = next; new-\u003eprev = prev; prev-\u003enext = new; } // 在链表头部添加节点 static inline void list_add(struct list_head *new, struct list_head *head) { __list_add(new, head, head-\u003enext); } // 删除节点的内部函数 static inline void __list_del(struct list_head *prev, struct list_head *next) { next-\u003eprev = prev; prev-\u003enext = next; } // 删除节点 static inline void list_del(struct list_head *entry) { __list_del(entry-\u003eprev, entry-\u003enext); entry-\u003enext = entry-\u003eprev = NULL; } // 获取包含链表节点的结构体指针的宏 #define offsetof(TYPE, MEMBER) ((size_t) \u0026((TYPE *)0)-\u003eMEMBER) #define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-\u003emember ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type, member) );}) // 获取链表节点对应的结构体指针 #define list_entry(ptr, type, member) \\ container_of(ptr, type, member) // 遍历链表的宏 #define list_for_each(pos, head) \\ for (pos = (head)-\u003enext; pos != (head); pos = pos-\u003enext) // 定义包含链表节点的结构体 struct my_data { int value; struct list_head list; }; // 初始化链表头 struct list_head my_list; // 添加节点 void add_node(struct list_head *head, int value) { struct my_data *new_node = malloc(sizeof(struct my_data)); new_node-\u003evalue = value; INIT_LIST_HEAD(\u0026new_node-\u003elist); list_add(\u0026new_node-\u003elist, head); } // 删除节点 void delete_node(struct my_data *node) { list_del(\u0026node-\u003elist); free(node); } // 查找节点 struct my_data* find_node(struct list_head *head, int value) { struct list_head *pos; list_for_each(pos, head) { struct my_data *entry = list_entry(pos, struct my_data, list); if (entry-\u003evalue == value) { return entry; } } return NULL; } // 打印链表 void print_list(struct list_head *head) { struct list_head *pos; list_for_each(pos, head) { struct my_data *entry = list_entry(pos, struct my_data, list); printf(\"%d \", entry-\u003evalue); } printf(\"\\n\"); } int main() { INIT_LIST_HEAD(\u0026my_list); add_node(\u0026my_list, 10); add_node(\u0026my_list, 20); add_node(\u0026my_list, 30); printf(\"List after adding nodes: \"); print_list(\u0026my_list); struct my_data *node = find_node(\u0026my_list, 20); if (node) { printf(\"Found node with value: %d\\n\", node-\u003evalue); delete_node(node); } printf(\"List after deleting node with value 20: \"); print_list(\u0026my_list); return 0; } ","date":"2024-05-25","objectID":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/:2:0","tags":null,"title":"链表","uri":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"linked list good taste 内容来自 linked list good taste // TODO: ","date":"2024-05-25","objectID":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/:3:0","tags":null,"title":"链表","uri":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"编译 建议在 WSL2 上操作，可以直接调用 N 卡加速，且无需复杂的配置依赖过程，首先安装 CUDA TOOLKIT 和 ccache： sudo apt install nvidia-cuda-toolkit ccache nvcc --version 下载 llama.cpp 并编译： git clone https://github.com/ggerganov/llama.cpp cd llama cmake -B build -DLLAMA_CUDA=ON cmake --build build --config Release ","date":"2024-05-03","objectID":"/llama.cpp-%E7%AE%80%E5%8D%95%E4%BD%93%E9%AA%8C/:1:0","tags":null,"title":"Llama.cpp 简单体验","uri":"/llama.cpp-%E7%AE%80%E5%8D%95%E4%BD%93%E9%AA%8C/"},{"categories":null,"content":"导入模型 在 llama 中新建文件夹存放中文模型： mkdir -p \"zh-models/7B/\" 这里使用 GitHub 项目 Chinese-LLaMA-Alpaca-2 的模型，下载位置，选择 ggml-model-q4_0.gguf 下载，完成后移动到上面新建的文件夹。 在根目录新建下面的脚本文件： #!/bin/bash # temporary script to chat with Chinese Alpaca-2 model # usage: ./chat.sh alpaca2-ggml-model-path your-first-instruction SYSTEM_PROMPT='You are a helpful assistant. 你是一个乐于助人的助手。' MODEL_PATH=$1 FIRST_INSTRUCTION=$2 ./build/bin/main -m \"$MODEL_PATH\" \\ -ngl 31 --color -i -c 4096 -t 8 --temp 0.5 --top_k 40 --top_p 0.9 --repeat_penalty 1.1 \\ --in-prefix-bos --in-prefix ' [INST] ' --in-suffix ' [/INST]' -p \\ \"[INST] \u003c\u003cSYS\u003e\u003e $SYSTEM_PROMPT \u003c\u003c/SYS\u003e\u003e $FIRST_INSTRUCTION [/INST]\" 使用 GPU 推理需要参数 -ngl，实测使用 RTX2060 的情况下 31 网上就已经无法正常输出结果了。运行脚本： chmod +x chat.sh ./chat.sh zh-models/7B/ggml-model-q4_0.gguf '请列举5条文明乘车的建议' 实测下来大部分问题都在胡言乱语。 ","date":"2024-05-03","objectID":"/llama.cpp-%E7%AE%80%E5%8D%95%E4%BD%93%E9%AA%8C/:2:0","tags":null,"title":"Llama.cpp 简单体验","uri":"/llama.cpp-%E7%AE%80%E5%8D%95%E4%BD%93%E9%AA%8C/"},{"categories":["Linux"],"content":"目录名称 gnome 桌面改回英文目录名： export LANG=en_US xdg-user-dirs-gtk-update export LANG=zh_CN ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:1:0","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"fonts Linux 上字体一般被存放在下面的文件夹（可通过 cat /etc/fonts/fonts.conf 查看）： /usr/share/fonts/ /usr/local/share/fonts/ ~/.fonts/ 安装 TrueType 字体 sudo apt install ttf-mscorefonts-installer 显示当前安装的字体： fc-list 如果需要手动安装字体，需要将解压后的字体文件或文件夹移动到上述的三个位置之一，然后刷新字体缓存： fc-cache -f -v ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:2:0","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"编译工具链 ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:3:0","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"gcc 14 下载和解压 gcc14.1： wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-14.1.0/gcc-14.1.0.tar.gz tar -xzvf gcc-14.1.0.tar.gz cd gcc-14.1.0/ 编译，官方 文档 中解释了各 configure 参数： # 安装依赖 sudo apt install libgmp-dev libmpc-dev libmpfr-dev libmpfrc++-dev libisl-dev texinfo # 如果执行了上一步依赖安装可以不用执行此脚本 ./contrib/download_prerequisites mkdir build \u0026\u0026 cd build # --program-suffix 会给安装的 gcc 程序添加后缀 ../configure --prefix=/opt/gcc-14.1.0 --enable-checking=release --enable-languages=c,c++,go --disable-multilib --enable-bootstrap --enable-threads=posix --program-suffix=-14 make -j$(nproc) sudo make install 环境变量设置： # gcc-14.1 ENV export GCC14_HOME=/opt/gcc-14.1.0 export PATH=$GCC14_HOME/bin:$PATH export LD_LIBRARY_PATH=$GCC14_HOME/lib64:$LD_LIBRARY_PATH Gcc 14 优化了静态分析特性，可以通过编译选项 -fanalyzer 检查死代码，可视化 buffer overflow 等。例如对下面的代码： void test (void) { char buf[10]; strcpy (buf, \"hello\"); strcat (buf, \" world!\"); } 编译将输出： \u003csource\u003e:7:3: note: write of 3 bytes to beyond the end of 'buf' 7 | strcat (buf, \" world!\"); | ^~~~~~~~~~~~~~~~~~~~~~~ \u003csource\u003e:7:3: note: valid subscripts for 'buf' are '[0]' to '[9]' ┌────┬────┬────┬────┬────┐┌─────┬─────┬─────┐ │[0] │[1] │[2] │[3] │[4] ││ [5] │ [6] │ [7] │ ├────┼────┼────┼────┼────┤├─────┼─────┼─────┤ │' ' │'w' │'o' │'r' │'l' ││ 'd' │ '!' │ NUL │ ├────┴────┴────┴────┴────┴┴─────┴─────┴─────┤ │ string literal (type: 'char[8]') │ └───────────────────────────────────────────┘ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ v v v v v v v v ┌─────┬────────────────────┬────┬──────────────┬────┐┌─────────────────┐ │ [0] │ ... │[5] │ ... │[9] ││ │ ├─────┼────┬────┬────┬────┬┼────┼──────────────┴────┘│ │ │ 'h' │'e' │'l' │'l' │'o' ││NUL │ │after valid range│ ├─────┴────┴────┴────┴────┴┴────┴───────────────────┐│ │ │ 'buf' (type: 'char[10]') ││ │ └───────────────────────────────────────────────────┘└─────────────────┘ ├─────────────────────────┬─────────────────────────┤├────────┬────────┤ │ │ ╭─────────┴────────╮ ╭───────────┴──────────╮ │capacity: 10 bytes│ │⚠️ overflow of 3 bytes│ ╰──────────────────╯ ╰──────────────────────╯ ... ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:3:1","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"CMake 没有 cmake 环境： ./bootstrap --qt-gui make \u0026\u0026 sudo make install 使用 CMake 构建： cmake -D BUILD_QtDialog=ON .. make \u0026\u0026 sudo make install ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:3:2","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"gdb 14.2 注意：目前不能使用 gcc-14 编译。 sudo apt install libreadline-dev libncurses* mkdir build \u0026\u0026 cd build ../configure --prefix=/opt/gdb-14.2 --enable-targets=all --with-python --enable-lto --enable-vtable-verify make -j6 \u0026\u0026 sudo make install 当在 VSCode 使用 gdb 遇到无法查看 STL 内容时，一般在调试控制台能看到如下信息： To enable execution of this file add add-auto-load-safe-path /opt/gcc-14.1.0/lib64/libstdc++.so.6.0.33-gdb.py line to your configuration file \"/home/username/.config/gdb/gdbinit\" 按上面提示新建文件并写入一般即可调试时查看 STL 内容，同时建议开启下面的打印选项，添加： set print pretty on set print object on set print static-members on set print vtbl on set print demangle on gdb 启动时会在下面三个位置查找启动脚本： ~/.config/gdb/gdbinit ~/.gdbinit ./.gdbinit 可选择使用开源项目优化 gdb 使用，例如 peda 适合逆向，gef 用于 debug。 ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:3:3","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"优化设置 点击程序坞图标，程序最小化： gsettings set org.gnome.shell.extensions.dash-to-dock click-action 'minimize' 关闭动效 gsettings set org.gnome.desktop.interface enable-animations false 隐藏桌面主目录和回收站图标： gsettings set org.gnome.shell.extensions.ding show-home false gsettings set org.gnome.shell.extensions.ding show-trash false 音视频编解码器： sudo apt-get install ubuntu-restricted-extras 音频控制： sudo apt install pulseaudio pavucontrol gnome 插件和优化选项： sudo apt install gnome-tweaks sudo apt install gnome-shell-extensions sudo apt install chrome-gnome-shell 切换 Wayland 和 X11，在位置 /etc/gdm3/custom.conf 根据注释操作。 ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:4:0","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"fcitx 5 安装 fcitx5 本体： sudo apt install fcitx5 fcitx5-chinese-addons fcitx5-frontend-gtk4 fcitx5-frontend-gtk3 fcitx5-frontend-gtk2 fcitx5-frontend-qt5 安装中文词库，下载页： wget https://github.com/felixonmars/fcitx5-pinyin-zhwiki/releases/download/0.2.4/zhwiki-20240426.dict mkdir -p ~/.local/share/fcitx5/pinyin/dictionaries/ mv zhwiki-20220416.dict ~/.local/share/fcitx5/pinyin/dictionaries/ 设为默认输入法，终端输入 im-config，按照提示设置。并添加环境变量： export XMODIFIERS=@im=fcitx export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx ubuntu 20.04 下 fcitx5 暂时不能图形化配置，安装命令： sudo apt install fcitx5 fcitx5-chinese-addons fcitx5-frontend-gtk3 fcitx5-frontend-gtk2 fcitx5-frontend-qt5 同样在 im-config 中设置系统输入法框架为 fcitx5，添加到开机启动项。新建文件 ~/.config/fcitx5/profile： [Groups/0] # Group Name Name=Default # Layout Default Layout=us # Default Input Method DefaultIM=pinyin [Groups/0/Items/0] # Name Name=keyboard-us # Layout Layout= [Groups/0/Items/1] # Name Name=pinyin # Layout Layout= [GroupOrder] 0=Default 修改 fcitx5 的配置文件时注意：先退出 fcitx5 再修改配置项，因为 fcitx5 进程退出后会覆写所有配置文件。 在文件 ~/.config/fcitx5/conf/pinyin.conf 中通过修改 PageSize 值调整候选字个数。重启后即可正常使用。 主题配置参见 github 项目 Fcitx5-Material-Color ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:5:0","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"neovim 安装剪贴板依赖： sudo apt install xclip 安装本体： curl -LO https://github.com/neovim/neovim/releases/latest/download/nvim-linux64.tar.gz sudo rm -rf /opt/nvim sudo tar -C /opt -xzf nvim-linux64.tar.gz export PATH=\"$PATH:/opt/nvim-linux64/bin\" ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:6:0","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"软件版本管理 对于使用 apt 安装的多个版本的包，可以使用 update-alternatives 命令管理软链接，进行版本切换。例如 editor 命令一般有以下的替代项： ± update-alternatives --config editor 有 5 个候选项可用于替换 editor (提供 /usr/bin/editor)。 选择 路径 优先级 状态 ------------------------------------------------------------ * 0 /bin/nano 40 自动模式 1 /bin/ed -100 手动模式 2 /bin/nano 40 手动模式 3 /usr/bin/code 0 手动模式 4 /usr/bin/vim.basic 30 手动模式 5 /usr/bin/vim.tiny 15 手动模式 使用 list 就只会列出当前备选项： ± update-alternatives --list editor 查看 editor 的链接位置可以发现他指向了 /etc/alternatives/editor，这个位置的软链再次指向 nano 的位置。 以切换 gcc 版本为例，如果计算机中已经安装了 gcc-11 和 gcc-12，此时 gcc 命令默认指向 gcc-11，通过下面的命令添加新的软链： sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-12 10 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 20 语法：--install link name path priority 参数： --install, Add a group of alternatives to the system /usr/bin/gcc, the generic name for the master link gcc, name is the name of its symlink in the alternatives directory path 添加命令的实际路径 priority 优先级 现在就给 gcc 添加了两个候选项，可通过 display 和 config 查看和设置： update-alternatives --display gcc update-alternatives --config gcc 一个 update-alternatives 服务可以添加多个从属 slave 命令，例如使用 gcc 一起管理 gcc、g++ 和 gcov 的版本： sudo update-alternatives --install /usr/bin/gcc gcc /opt/gcc-14.1.0/bin/gcc-13 20 --slave /usr/bin/g++ g++ /opt/gcc-14.1.0/bin/g++-13 --slave /usr/bin/gcov gcov /opt/gcc-14.1.0/bin/gcov-13 删除某个版本： sudo update-alternatives --remove gcc /opt/gcc-14.1.0/bin/gcc-13 可以使用 GUI 程序 galternatives 进行可视化管理： sudo apt install galternatives ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:7:0","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"Virtualbox 共享文件夹提示无权限访问，因为 /media 下挂载的文件夹用户是 root, 应把当前用户添加到 vboxsf 组中，执行命令后重启。 sudo usermod -aG vboxsf $(whoami) ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:8:0","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"multipass Ubuntu 官方提供的 multipass 程序能够更方便得管理 ubuntu 虚拟机，尤其在 Apple M 系列芯片的机型。安装程序后，使用下面的命令创建新的虚拟机： multipass launch -n ubuntu24 --cpus 4 --disk 32G --memory 4G 操作方式和 docker 类似： multipass shell ubuntu24 # 交互方式进入虚拟机 multipass list # 列出当前实例 multipass delete ubuntu24 # 删除实例 multipass recover ubuntu24 # 恢复实例 multipass purge # 永久删除实例 multipass find # 查询支持的镜像列表 对于 arm 架构的 ubuntu，需要更换 Ubuntu Ports 源。 ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:9:0","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"WSL 默认系统 ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:10:0","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["Linux"],"content":"参考 How to install and manage fonts on Linux GCC-13.2.0 编译安装 Improvements to static analysis in the GCC 14 compiler 在 Ubuntu 安装配置 Fcitx 5 中文输入法 如何现在就在 Ubuntu 20.04 用上 Fcitx 5 在 Ubuntu Linux 上安装 Fcitx5 中文输入法 我也！用上 fcitx5 了 The update-alternatives Command in Linux Ubuntu24.04 版本下实现 gcc 版本的快速切换 VirtualBox: linux 没有权限访问共享文件夹的问题 虚拟机管理工具 multipass 使用笔记 ","date":"2024-04-29","objectID":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:11:0","tags":["Linux"],"title":"Ubuntu 相关常用问题","uri":"/ubuntu-%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":null,"content":"whisper 是 openai 开源的可离线使用的语音识别模型。目前的缺点是只能产生英文的字幕文件。 ","date":"2024-04-07","objectID":"/whisper-%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8/:0:0","tags":null,"title":"Whisper 语音模型使用","uri":"/whisper-%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"Windows Windows 上使用的优势是能调用 Nvidia 显卡加速。 下载： WhisperDesktop ggml 语音模型，可以通过国内镜像站点下载，文件越大，识别效果越好，耗时和占用资源越多。 使用： 解压 WhisperDesktop 后点击 WhisperDesktop.exe 运行，并选择下载好的模型文件。 在 Advanced 中选择独显。 选择待识别的 mp3 文件，如果是视频文件可以先使用 ffmpeg 转换成 mp3 后再进行操作。选择产生 “SubRip subtitles\"文件（SRT 字幕），点击 Transcribe 开始生成字幕。 图中的 “Translate” 选项是指视频是其他语言，需要转成英文，而非直接产生其他语言的字幕。 最后产生 srt 字幕文件后，在 vlc 中选择并添加即可。实测使用 RTX2060 + ggml-large-v2 模型的情况下，产生一个多小时讲座的字幕花费 17 分钟左右。 ","date":"2024-04-07","objectID":"/whisper-%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8/:1:0","tags":null,"title":"Whisper 语音模型使用","uri":"/whisper-%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"MacOS ","date":"2024-04-07","objectID":"/whisper-%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8/:2:0","tags":null,"title":"Whisper 语音模型使用","uri":"/whisper-%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"安装 ","date":"2024-03-21","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/manim/:0:0","tags":null,"title":"Manim","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/manim/"},{"categories":null,"content":"MacOS 在 MacOS 上推荐创建虚拟环境后再使用 pip 安装依赖包。直接使用 pip3 安装会导致如下错误： error: externally-managed-environment × This environment is externally managed ╰─\u003e To install Python packages system-wide, try brew install xyz, where xyz is the package you are trying to install. If you wish to install a non-brew-packaged Python package, create a virtual environment using python3 -m venv path/to/venv. Then use path/to/venv/bin/python and path/to/venv/bin/pip. If you wish to install a non-brew packaged Python application, it may be easiest to use pipx install xyz, which will manage a virtual environment for you. Make sure you have pipx installed. 创建虚拟环境再处理： python3 -m venv /Users/kali/pyvirtual /Users/kali/pyvirtual/bin/pip install manim 一般会提示关于 No package ‘pangocairo’ found 的相关错误。解决方法： brew install cairo brew install pango 类似的，Arch Linux 上安装同样会出现上述错误：输入 sudo pacman -S cairo pango 解决。 然后会提示 Could not build wheels for Pillow 的相关错误，解决方式： brew install libtiff libjpeg webp little-cms2 接下来一般能构建成功。 或者使用 pipx： brew install pipx pipx install manim --include-deps ","date":"2024-03-21","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/manim/:1:0","tags":null,"title":"Manim","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/manim/"},{"categories":null,"content":"Mac 下 GUI 程序不显示 编译示例图形界面程序后，程序坞出现图标但是不显示窗体。需要在项目的 .pro 文件添加： CONFIG += sdk_no_version_check QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.15 清理当前构建后重新编译即可。 ","date":"2024-03-21","objectID":"/draft/%E7%99%BE%E7%A7%91/qt-%E7%9B%B8%E5%85%B3/:1:0","tags":null,"title":"Qt 相关","uri":"/draft/%E7%99%BE%E7%A7%91/qt-%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"Linux 下 QM 无法启动 ubuntu 下安装 QP/C 框架后，qm 程序无法启动。需要安装依赖项： sudo apt install qtwayland5 '^libxcb.*-dev' libx11-xcb-dev libglu1-mesa-dev libxrender-dev libxi-dev libxkbcommon-dev libxkbcommon-x11-dev ","date":"2024-03-21","objectID":"/draft/%E7%99%BE%E7%A7%91/qt-%E7%9B%B8%E5%85%B3/:2:0","tags":null,"title":"Qt 相关","uri":"/draft/%E7%99%BE%E7%A7%91/qt-%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"参考 mac qt问题记录 qt.qpa.plugin: Could not load the Qt platform plugin “xcb” in \"\" even though it was found. ","date":"2024-03-21","objectID":"/draft/%E7%99%BE%E7%A7%91/qt-%E7%9B%B8%E5%85%B3/:3:0","tags":null,"title":"Qt 相关","uri":"/draft/%E7%99%BE%E7%A7%91/qt-%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"安装 Windows 上 Docker 需要基于 Hyper-V 或者 WSL2。在“启用或关闭 Windows 功能”中勾选 “Hyper-V” 和“容器”，进而再安装 Docker Desktop。 安装 Docker Desktop 后可以 Settings –\u003e Resources –\u003e WSL Integration 选择 Enable integration with additional distros。这样 WSL2 中即可直接使用 Windows 上安装的 Docker 环境。 但槽点是，如果安装过 Docker Desktop，则可能会改变 WSL 的默认系统设置，导致 VSCode 选择“连接到 WSL”选项时，会连接到 docker-desktop 导致失败。下面的选项修改默认设置： \u003e wsl -l -v NAME STATE VERSION * docker-desktop Stopped 2 docker-desktop-data Stopped 2 Arch Stopped 2 Ubuntu-24.04 Running 2 \u003e wslconfig /setdefault Ubuntu-24.04 Linux 上可以直接使用 apt 的源下载 Ubuntu 维护的社区版 docker。 sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release usbutils sudo apt install docker.io docker-compose docker-doc 安装完成后，docker 默认 root 用户才能访问，所以要添加当前用户名到 docker 组中。 sudo usermod -aG docker ${USER} 执行后需要重启，重启后输入以下命令查看用户名是否被添加到组中： id -nG 现在直接执行 docker 命令就不会报错。 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:1:0","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"概念 image: 一个只读的模板，可以用来创建 Docker 容器。相当于安装虚拟机时的 iso 文件。 container: 容器镜像的运行实例。 dockerfile: 用于制作、部署容器镜像的配置文件。 容器和虚拟机的区别可以参考虚拟机与容器区别。 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:2:0","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"基础命令 首先建议换阿里源，如果在 Linux 命令行下使用，可以通过修改 daemon 配置文件 /etc/docker/daemon.json 实现，保存重新加载 daemon 并重启容器。 sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://xxx.mirror.aliyuncs.com\"], \"insecure-registries\": [ \"ip:port\" ] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 如果使用 Docker Desktop 则可以在 settings 的 Docker Engine 选项中直接编辑。 常用命令： # 从互联网拉取名为 ubuntu 的容器 docker pull ubuntu # 首次从镜像创建名为 MyContainer 的容器实例，进入交互模式，运行程序 zsh docker run -it --name MyContainer ubuntu zsh # 首次启动一个特权容器，映射了外部 linux usb 设备，硬件调试需要 docker run -it --name MyContainer --privileged -v /dev/bus/usb/:/dev/bus/usb ubuntu zsh # 查询容器实例列表 docker ps -a # 显示当前容器 ID 和容器名 # 提交容器变更，产生名为 ubuntu:base 的新镜像 -a: 作者，-m: 说明 docker commit -a \"mufasa\" -m \"change mirror\" container-id ubuntu:base # 再次启动容器实例 docker start MyContainer # 进入交互模式（运行 zsh） docker exec -it MyContainer zsh # 删除容器实例，可通过容器 id 号或者容器名称 docker rm ${CONTAINER ID} docker rm ${NAMES} # 删除镜像 docker rmi ${REPOSITORY} # 保存当前 image 为 tar 文件 docker save ubuntu \u003e ubuntu.tar # linux docker save --output ubuntu.tar ubuntu # 导入 image docker load \u003c ubuntu.tar # linux docker load --input ubuntu.tar ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:3:0","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"UI 工具 docker desktop lazydocker VSCode docker 插件 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:4:0","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"SSH 以及基础编译环境配置 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:5:0","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"Ubuntu ubuntu 默认镜像拉取后需要先使用默认源安装 ca-certificates，之后才能换源。 由于容器默认没有文本编辑器，可以使用 cat 或者 echo 用重定向标准输入的方式直接覆盖源文件。 cat \u003e/etc/apt/sources.list # 获取输入内容...，Ctrl + d 结束 安装 OpenSSH 服务，设置 root 密码 apt install openssh-server passwd: # 修改密码 OpenSSH 的客户端软件是 ssh，服务器软件是 sshd，服务器默认监听端口是 22。启动镜像时分配端口号映射，把本机的 6789 端口映射到容器 22 号端口： docker run -itd -p 6789:22 image-name Windows powershell 下可以使用 netstat -a 查看端口 6789 是否被正常打开。使用 exec 和运行中的容器交互： docker exec -it container-id /bin/bash 修改容器中的 sshd_config 配置文件，开启密码访问： vim /etc/ssh/sshd_config #PermitRootLogin prohibit-password 在此行后添加 PermitRootLogin yes 在容器中执行： service ssh start # 或者 /etc/init.d/ssh start 此时本机终端可以连接容器内部。 ssh root@127.0.0.1 -p 6789 对于 Windows，系统变量下默认的 ssh 工具连接会存在问题，建议更换成 git 安装目录下 /usr/ssh.exe 对于 VSCode，安装插件 Remote SSH 后，选择将当前窗口连接到主机，填写 ssh root@127.0.0.1 -p 6789，输入密码即可连接完成。 使用 ssh 复制文件： # 远程复制到本机，scp 命令已经不再推荐 scp -p 22 username@ipaddress:/home/xxx/ . # 复制文件到远程 rsync -p 22 filename username@ipaddress:/home/xxx/ ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:5:1","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"alpine alpine 发行版更加轻量，并且不需要安装 ca-certificates 换源，比较容易写 Dockerfile。alpine 使用 apk 作为包管理工具，且没有 bash。基础编译工具通过 apk add build-base 安装。 apk add openrc openssh iptables 然后执行： rc-update add sshd rc-status # 确认 sshd 监听状态 rc-service sshd start 其他步骤和 ubuntu 中相同。 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:5:2","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"Fedora RedHat 维护的发行版，默认安装的编译环境较新。使用 dnf 作为包管理器。但是默认甚至不支持 clear 命令。 sudo dnf group install \"C Development Tools and Libraries\" \"Development Tools\" sudo dnf install ncurses # 支持 clear sudo dnf install clang-tools-extra # 安装 clangd ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:5:3","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"mcr 微软官方 DevContainer 插件官方维护的系列容器，在普通容器的基础上添加了权限管理，zsh 和一个名为 vscode 的非 root 用户，已经配置了一些常用的系统工具。 docker pull mcr.microsoft.com/devcontainers/base:ubuntu ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:5:4","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"私有 Registry 为了在 Dockerfile 中使用自定义的镜像，并且分享镜像到局域网，需要使用 Docker Registry 容器。 docker pull registry docker run --name MyHub -d -p 5000:5000 -v /f/docker_registry:/var/lib/registry registry 启动时添加映射端口，添加局域网或本地存放仓库的位置到容器路径 /var/lib/registry 的映射。启动后需要给要上传的镜像打上标签，这里以镜像 alpine:cpp 为例： docker tag alpine:cpp your_ip:5000/alpine:cpp 上传之前先添加局域网 ip:port 到 Docker Engine 的 json 文件中，否则会上传失败。 { \"builder\": { \"gc\": { \"defaultKeepStorage\": \"20GB\", \"enabled\": true } }, \"experimental\": false, # 添加此段 \"insecure-registries\": [ \"ip:port\", \"ip:port\" ] } 点击应用并重启镜像，上传： docker push your_ip:5000/alpine:cpp 只要局域网内其他人也添加了相同的 \"insecure-registries\" 字段，就能访问 registry 容器内的自定义镜像。下载命令： docker pull your_ip:5000/alpine:cpp 如果局域网内有多个镜像，可以使用 curl 查看本地镜像列表： curl your_ip:5000/v2/_catalog 如果只是本机使用，可以在 tag 和 push 阶段直接使用主机环回地址： docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest 这种情况下无需编辑 Docker Engine 中的 json 文件即可拉取自定义镜像。 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:6:0","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"GUI ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:7:0","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"Windows 在 Windows 下安装带有 X11 服务的软件，例如 X410，VcXsrv，MobaXterm 等。 编写下列的 Dockerfile，以简单钟表程序 xarclock 为例： FROM ubuntu:18.04 # 换源操作略 # 安装 xarclock RUN apt-get update \u0026\u0026 apt-get install -y xarclock CMD /usr/bin/xarclock 使用以下命令构建： docker build -t xarclock . docker run -ti --rm -e DISPLAY=host.docker.internal:0.0 xarclock Docker 推荐容器使用 host.docker.internal 来访问宿主机上的服务。输出乱码需要在容器中安装对应语言、地区和字体。 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:7:1","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"Linux Linux 同样通过 x11 服务显示，启动参数有所不同： sudo apt install x11-xserver-utils sudo xhost + # access control disabled, clients can connect from any host docker run -it -v /etc/localtime:/etc/localtime:ro \\ -v /tmp/.X11-unix:/tmp/.X11-unix \\ -e DISPLAY=unix$DISPLAY \\ -e GDK_SCALE \\ -e GDK_DPI_SCALE \\ --name GUITEST ubuntu zsh ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:7:2","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"嵌入式 Debug Windows 下 WSL 环境的容器，目前对宿主机设备的访问支持不完善，无法直接调试。Linux 主机上的容器可以通过设备映射的方式 Debug。 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:8:0","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"方法一 J-Link 官方提供了在 Linux 宿主机上直接用设备映射访问调试器的文档，容器内需要安装 lsusb 支持。 apt install usbutils sudo docker run -t -i --privileged -v /dev/bus/usb/:/dev/bus/usb ubuntu bash ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:8:1","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"方法二 在 Windows 的容器环境下，比较容易做到的方法是使用 GdbServer 进行远程调试。 gdbserver is a control program for Unix-like systems, which allows you to connect your program with a remote GDB via target remote or target extended-remote—but without linking in the usual debugging stub. 在使用 cortex-debug 插件和 J-Link 的情况下，在 launch.json 中添加如下配置： { \"name\": \"Remote GdbServer\", \"request\": \"launch\", \"type\": \"cortex-debug\", \"cwd\": \"${workspaceFolder}\", \"executable\": \"./build/xxx.elf\", \"runToEntryPoint\": \"main\", \"showDevDebugOutput\": \"none\", \"servertype\": \"external\", \"preRestartCommands\": [ \"file ./build/xxx.elf\", \"load\", \"enable breakpoint\", \"monitor reset\", \"monitor halt\" ], \"gdbPath\": \"gdb-multiarch\", \"objdumpPath\": \"arm-none-eabi-objdump\", \"gdbTarget\": \"host.docker.internal:2331\" } 调试前在 Windows 端打开 J-LinkGDBServer.exe，选择设备和接口类型。arm-none-eabi-gdb 在容器中用 tcp 通过端口 2331 实现和宿主机中 J-LinkGDBServer 的通信。从而实现正常的调试功能。 Linux 下如果要使用图形化的 JlinkGdbServer, 需要下载 libqtgui4 使用 openocd 也能实现类似的功能。 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:8:2","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"方法三 也可以直接使用 J-Link Remote Server，配置正确的 IP 地址实现调试。以 LAN mode 在宿主机启动 J-Link Remote Server。添加如下的调试配置： { \"name\": \"Remote IP\", \"request\": \"launch\", \"type\": \"cortex-debug\", \"cwd\": \"${workspaceFolder}\", \"executable\": \"./build/xxx.elf\", \"device\": \"xxx\", \"interface\": \"swd\", \"runToEntryPoint\": \"main\", \"showDevDebugOutput\": \"none\", \"servertype\": \"jlink\", \"preRestartCommands\": [ \"file ./build/xxx.elf\", \"load\", \"enable breakpoint\", \"monitor reset\", \"monitor halt\" ], \"gdbPath\": \"gdb-multiarch\", \"objdumpPath\": \"arm-none-eabi-objdump\", \"serverpath\": \"JLinkGDBServerCLExe\", \"ipAddress\": \"xxx.xxx.xxx.xxx\", } 即直接使用本地的 JLinkGDBServerCLExe 服务，通过实际的 IP 地址远程调试。实际使用中经常断连，不推荐这样调试。 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:8:3","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"Harbor Harbor 是一个开源的镜像仓库管理方案，集成了反向代理，数据库等功能。提供了网页的管理界面，能实现对镜像的访问控制，漏洞扫描等功能。可以在 WSL2 或者各种 Linux 发行版部署，目前不适用于 ARM 系列芯片的 MacOS 系统。 下载并解压 offline 版本的安装包后，首先完成配置文件。 cp harbor.yml.tmpl harbor.yml vim harbor.yml 修改 hostname 为对外访问的 IP 地址。默认 80 端口，暂时注释掉 HTTPS 部分的配置。 # The IP address or hostname to access admin UI and registry service. # DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients. hostname: ip_addr # http related config http: # port for http, default is 80. If https enabled, this port will redirect to https port port: 80 # https related config # https: # https port for harbor, default is 443 # port: 443 # The path of cert and key files for nginx # certificate: /your/certificate/path # private_key: /your/private/key/path # enable strong ssl ciphers (default: false) # strong_ssl_ciphers: false 配置完成后即可执行 sudo ./install.sh , 执行安装前建议先像配置 Registry 一样将 \"insecure-registries\": [\"ip_addr:80\"] 添加到 Docker Engine 的 json 文件中。 docker compose 服务启动后，可以在浏览器输入 ip_addr:80 访问 harbor 网页端，默认用户名 admin，密码：Harbor12345。 通过管理界面创建一个 push 镜像需要登陆，pull 没有限制的仓库，通过 新建项目 添加。 下面将制作好的镜像上传到新建的 public 仓库，首先按照下面的格式修改镜像 tag： docker tag fedora:cpp ip_addr:80/public/fedora:cpp push 之前先在终端登录 Harbor： \u003e docker login ip_addr:80 Username: admin Password: Login Succeeded \u003e docker push ip_addr:80/public/fedora:cpp 这样在网页后台就能看到上传的镜像，其他人可直接复制 pull 镜像的指令。 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:9:0","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"VSCode 容器和 VSCode 可以良好结合，需要安装插件 Docker 和 Dev Containers。进入 VSCode 点击远程可以选择附加到运行的容器打开。 注意当首次进入容器时，VSCode 会在容器中安装 code-server 服务。如果当前网络环境不允许容器联网，需要手动拷贝 vscode-server 到容器内。在 “关于\"中查看当前 VSCode 的“提交”commit-id，2023 年之前可以访问 https://update.code.visualstudio.com/commit:${commit_id}/server-linux-x64/stable , 2023 年之后访问 https://vscode.download.prss.microsoft.com/dbazure/download/stable/${commit_id}/vscode-server-linux-x64.tar.gz。 code-server 服务安装的位置和容器的用户名有关，例如对于微软的 mcr 系列容器镜像，在 /home 下定义了一个名为 vscode 的非 root 用户。因此 code-server 会被安装在 /home/vscode/.vscode-server/bin/commit-id。而普通容器默认用户是 root，那么 code-server 会安装在 /root/.vscode-server/bin/commit-id。 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:10:0","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"参考 Docker - Docker for Windows 10 入門篇 WSL2 切换默认的 Linux 子系统 镜像加速器 SSH 服务器 Alpine Linux 常用命令 Setting up a SSH server 通过 SSH 在远程和本地系统之间传输文件的 4 种方法 docker 搭建本地/局域网仓库 私有仓库 about – x11 display server – display or login manager – window manager 在 Docker for Windows 中运行 GUI 程序 Run GUI app in linux docker container on windows host “error: XDG_RUNTIME_DIR not set in the environment.” when attempting to run nautilus as root Docker 容器图形界面显示（运行 GUI 软件）的配置方法 J-Link Docker Container Win10 中的 Docker 使用 USB 设备 Using the gdbserver Program Developing on the RP2040 / Pi Pico with Docker and JLink vscode + jlink + GDBServer 在线调试 J-Link GDB Server STM32 Development Env for Windows: VSCode + ARM GCC Toolchain + OpenOCD WSL Run the Installer Script VS Code Server 离线安装过程 ","date":"2024-03-09","objectID":"/docker-%E9%85%8D%E7%BD%AE/:11:0","tags":null,"title":"Docker 基础","uri":"/docker-%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"封装 ","date":"2024-02-25","objectID":"/draft/cpp/c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:1:0","tags":null,"title":"[未完成] C 语言面向对象编程","uri":"/draft/cpp/c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"继承 ","date":"2024-02-25","objectID":"/draft/cpp/c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:2:0","tags":null,"title":"[未完成] C 语言面向对象编程","uri":"/draft/cpp/c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"多态 ","date":"2024-02-25","objectID":"/draft/cpp/c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:3:0","tags":null,"title":"[未完成] C 语言面向对象编程","uri":"/draft/cpp/c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"参考 面向对象编程 (OOP) 的 C 语言实现 C++ this 指针的理解和作用 Object-Oriented Programming ","date":"2024-02-25","objectID":"/draft/cpp/c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:4:0","tags":null,"title":"[未完成] C 语言面向对象编程","uri":"/draft/cpp/c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"总体结构 ","date":"2024-02-25","objectID":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/:1:0","tags":null,"title":"[未完成] QP 状态机编程","uri":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"概念 ","date":"2024-02-25","objectID":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/:2:0","tags":null,"title":"[未完成] QP 状态机编程","uri":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"AO ","date":"2024-02-25","objectID":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/:2:1","tags":null,"title":"[未完成] QP 状态机编程","uri":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"事件驱动 ","date":"2024-02-25","objectID":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/:2:2","tags":null,"title":"[未完成] QP 状态机编程","uri":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"设计模式 ","date":"2024-02-25","objectID":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/:3:0","tags":null,"title":"[未完成] QP 状态机编程","uri":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"主动对象模式 ","date":"2024-02-25","objectID":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/:3:1","tags":null,"title":"[未完成] QP 状态机编程","uri":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"发布订阅模式 ","date":"2024-02-25","objectID":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/:3:2","tags":null,"title":"[未完成] QP 状态机编程","uri":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"使用方法 ","date":"2024-02-25","objectID":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/:4:0","tags":null,"title":"[未完成] QP 状态机编程","uri":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"移植过程 ","date":"2024-02-25","objectID":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/:5:0","tags":null,"title":"[未完成] QP 状态机编程","uri":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"Design by Contract ","date":"2024-02-25","objectID":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/:6:0","tags":null,"title":"[未完成] QP 状态机编程","uri":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"参考 Design by Contract ","date":"2024-02-25","objectID":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/:7:0","tags":null,"title":"[未完成] QP 状态机编程","uri":"/draft/%E5%B5%8C%E5%85%A5%E5%BC%8F/qp%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"C 风格数组退化 C 语言传递数组时，数组类型会退化（decay）成指针类型，同时丢失长度信息。 C 风格的数组在大多数情况下退化为指针，认为数组 = 指针是常见的谬误。数组是一个元素序列，而指针只保存一个地址。 // [] 中的长度是无效的，所以不需要填 void printElementZero(const int arr[], int length); // 等同于 void printElementZero(const int* arr, int length); ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:1:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"字符串 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:2:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"C 风格字符串 C 风格的两种字符串定义方式： const char name[] { \"Alex\" }; // case 1 const char* const color{ \"Orange\" }; // case 2 case 1 中，“Alex\\0” 先分配在只读段，然后 char 类型长度为 5 的数组，再使用 “Alex\\0” 填充。所以存在两个副本。 case 2 中，“Orange” 被放入只读段，使用字符串的地址初始化指针。 auto 推导字符串： auto s1{ \"Alex\" }; // type deduced as const char* auto* s2{ \"Alex\" }; // type deduced as const char* auto\u0026 s3{ \"Alex\" }; // type deduced as const char(\u0026)[5] ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:2:1","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"string TODO: 为什么大部分情况下导出的都是 C 风格字符串的接口 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:2:2","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"utf-8 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:2:3","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"操作符 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:3:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"sizeof 语法： sizeof( 类型 ) (1) sizeof 表达式 (2) sizeof a + b 会被解释成 sizeof(a) + b。 当应用于类类型时，结果是该类的完整对象所占据的字节数，包括这种对象放入数组时所需的任何额外填充。 sizeof 的结果始终非零，即使应用于空类，一般是 1。 class A {}; // sizeof(A) = 1; class B : public A { int x; }; // sizeof(B) = 4; class C { // sizeof(C) = 8; A a; B b; }; 空基类优化：为保证同一类型的不同对象地址始终有别，要求任何对象或成员子对象的大小至少为 1，即使该类型是空的类类型。空类的派生类可以允许空的基类子对象大小为零。 当应用于某个表达式时，sizeof 不对表达式进行求值，即便表达式代表多态对象，它的结果也是该表达式的静态类型的大小。 int a = 1; std::size_t b = sizeof ++a; std::cout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c \"\\n\"; ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:3:1","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"CV 限定符 const —— 定义类型为常量类型，reade only。 volatile —— 定义类型为易变类型。 直接修改 const 修饰的变量会编译失败，通过指针或引用修改则行为未定义 一般需要关键字 volatile 的场合： Memory-mapped peripheral registers Global variables modified by an interrupt service routine Global variables within a multi-threaded application 不应该将二者理解成反义词： const 保证被修饰的变量不会被程序（程度员）修改，但不负责源码以外被修改的情况。 volatile 说明变量可能被硬件改变，告知编译器不要优化此处 uint8_t volatile *const pReg = (uint8_t*)0x40000000; uint8_t const volatile *const pReg = (uint8_t*)0x40000000; 第一句说明常量指针 pReg 指向的 uint8_t 类型值，即地址 0x40000000 处的值可能被硬件修改。第二句说明，0x40000000 处的值可能被硬件修改，但不允许程序员修改。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:4:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"auto / decltype auto 自动类型推导： auto 总是优先推导为值类型 可以结合 cv 限定符，* 和 \u0026 得到新类型 auto\u0026\u0026 可被推导成左值引用或右值引用类型 auto x = 10L; auto\u0026 x1 = x; auto* x2 = \u0026x; const auto\u0026 x3 = x; auto x4 = \u0026x3; auto\u0026\u0026 x5 = x; decltype 不仅能推导出值类型，还可以推导出引用类型。 语法 说明 decltype ( 实体 ) (1) (C++11 起) decltype ( 表达式 ) (2) (C++11 起) cppref: 注意如果对象的名字带有括号，那么它会被当做普通的左值表达式，因此 decltype(x) 和 decltype((x)) 通常是不同的类型。 int z = 0; decltype(z)\u0026 z2 = z; // z2 推导为 int\u0026 decltype(z2) z6 = z2; // z6 推导为 int\u0026 auto z7 = z2; // z7 推导为 int C++14 后，如果占位类型说明符是 decltype(auto)，那么推导出的类型是 decltype(expr)。 int y = 10; decltype(auto) y1 = (y); // 推导为 int\u0026, 因为（expr）是引用类型。 decltype(auto) y2 = \u0026y; // 推导为 int* decltype(auto) y3 = y1; // 推导为 int\u0026 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:5:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"引用 C 语言中的 NULL 可以被定义为 0、0L、((void*)0) 或者其他，当空指针仍然使用 NULL 时，可能会出现问题： void print(int x) { std::cout \u003c\u003c \"print(int): \" \u003c\u003c x \u003c\u003c std::endl; } void print(int* ptr) { std::cout \u003c\u003c \"print(int*): \" \u003c\u003c (ptr ? \"non-null\\n\" : \"null\\n\"); } int main() { print(0); print(NULL); // clang / gcc 下编译错误，MSVC print(int) print(nullptr); return 0; } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:6:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"初始化 C++ 中，初始化不等于赋值 – C++ primer 总体而言，C++ 的初始器 (initializer) 分为： 复制初始化 = expression 直接初始化 ( ) 列表初始化 = { } 复制初始化可能调用非 explicit 的构造函数，拷贝构造函数，或者是移动构造函数。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:7:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"函数重载 // TODO: 重载函数规则： 注意，重载函数之间不一定需要完全独立，可以通过委托已经实现的同名函数进行重载，比如： void printMessage(const std::string\u0026 message) { std::cout \u003c\u003c \"Message: \" \u003c\u003c message \u003c\u003c std::endl; } void printMessage(int number) { printMessage(std::to_string(number)); // 嵌套调用另一个重载函数 } printMessage(\"Hello, World!\"); printMessage(42); 这种手段可以增强复用性。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:8:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"枚举 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:9:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"C-style enum 普通枚举，将被隐式转换成整数，类型不安全。 enum Color { red,green,blue, }; 枚举名称非必须，但现代 C++ 应避免未命名的枚举。 可以指定枚举的基础类型，默认一般是 int。 enum Color : std::int8_t { black,red,blue, }; ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:9:1","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"enum class 枚举类不属于类类型，需要作用域解析运算符访问，能避免和其他枚举定义重名的问题，不会隐式转换成整数，类型安全。 enum class Color { red,green,blue, }; C++ 20 起 using 可用于枚举： enum class Status{open, progress, done = 9}; void print(Status s) { switch (s) { using enum Status; // 或者：using Status::open, Status::done, Status::progress; case open: std::cout \u003c\u003c \"open\"; break; case progress: std::cout \u003c\u003c \"in progress\"; break; case done: std::cout \u003c\u003c \"done\"; break; } } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:9:2","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"函数指针和 std::function TODO: 普通函数指针： 使用 typedef 作为声明标识符，为函数指针起别名，实现回调函数： // 函数指针类型，下面的语句定义的名字是 Button_Call，代表 void ()(void*) 类型的函数 typedef void (*Button_Call)(void*); // 回调函数实现 void myButtonPressed(void* data) { printf(\"Button pressed data: %d\\n\", *((int*)data)); } // 注册回调 void registerButtonPressCallback(Button_Call func, void * data) { func(data); } int main(int argc, char *argv[]) { int somedata = 42; registerButtonPressCallback(myButtonPressed, \u0026somedata); return 0; } 技巧：using + decltype 完成函数指针获取 int add(int a, int b) { return a + b; } using add_ptr_t = decltype(\u0026add); add_ptr_t my_add_ptr = add; ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:10:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"表达式 表达式是运算符和它们的操作数的序列，指定一项计算。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:11:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"初等表达式（Primary expressions） 包括： this 字面量（例如 2 或 “Hello, world”） 标识表达式 lambda 表达式 (C++11 起) 折叠表达式 (C++17 起) requires 表达式 (C++20 起) 任何带括号表达式也被归类为初等表达式。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:11:1","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"常量表达式 constexpr 和 const 存在结合使用的场景，例如下面的代码会出现警告： constexpr char *msg = \"Hello, world!\"; \u003e warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings] constexpr 会隐式在顶层添加一个 const 限定符： constexpr T a = xxx; // 等价于： T const a = xxx; 因此字符串本身的常量性未修饰。应该修改为： constexpr const char *p = \"Hello, world!\"; 思考下面的例子： /* * +----------+ +-----+ +-----+ * +-------- |const char|*|const|*|const| p * | +----------+ +--+--+ +--+--+ * | | | * | +--------------------+ | * | | | * | | +----------------+ * | | | * | | v +-----------------+ * | | ptr --\u003e| 0x1000 | * | | +-----------------+ * | | * | | +-----------------+ * | +-------\u003e 0x1000--\u003e| 0x2000 | * | +-----------------+ * | * | +-----------------+ * +------------\u003e 0x2000--\u003e| 'A' | * +-----------------+ */ constexpr char a = 'A'; constexpr const char* p = \u0026a; constexpr const char* const * pp = \u0026p; const char b = 'A'; const char* const q = \u0026a; const char* const * const qq = \u0026p; ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:11:2","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"完整表达式（Full-Expression） 初始化 常量表达式 立即调用（consteval） 未求值的操作数 不是子表达式的表达式 右值对象在创建它的完整表达式的末尾被销毁。对右值对象成员的任何引用都将在该点悬空。对右值对象成员的引用只能在创建右值对象的完整表达式中安全使用。 下面的 case2 属于未定义行为。 class Employee { std::string m_name{}; public: void setName(std::string_view name) { m_name = name; } const std::string\u0026 getName() const { return m_name; } // getter returns by const reference }; // createEmployee() returns an Employee by value (which means the returned value is an rvalue) Employee createEmployee(std::string_view name) { Employee e; e.setName(name); return e; } int main() { // Case 1: okay: use returned reference to member of rvalue class object in same expression std::cout \u003c\u003c createEmployee(\"Frank\").getName(); // Case 2: bad: save returned reference to member of rvalue class object for use later const std::string\u0026 ref { createEmployee(\"Garbo\").getName() }; // reference becomes dangling when return value of createEmployee() is destroyed std::cout \u003c\u003c ref; // undefined behavior // Case 3: okay: copy referenced value to local variable for use later std::string val { createEmployee(\"Hans\").getName() }; // makes copy of referenced member std::cout \u003c\u003c val; // okay: val is independent of referenced member return 0; } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:11:3","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"仿函数（functor） 通过在类内对 () 运算符进行重载可以得到仿函数，也称函数对象。仿函数可以拥有初始状态，一般通过 class 定义私有成员，在声明对象时初始化，私有成员的状态成为仿函数的初始状态。带状态的仿函数与 lambda 类似，仿函数可以用于实现 lambda 表达式（C++11）。 class Tax { private: float rate; int base; public: Tax(float r, int b) :rate(r), base(b) { } float operator()(float money){ return (money - base)*rate; } }; int main(int argc, char *argv[]) { // \u003c-- functor Tax high(0.40, 30000); Tax middle(0.25, 20000); cout \u003c\u003c \"tax over 3w: \" \u003c\u003c high(37500) \u003c\u003c endl; cout \u003c\u003c \"tax over 2w: \" \u003c\u003c middle(27500) \u003c\u003c endl; } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:12:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"lambda ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:13:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"偏函数 参数较多的函数，某些场合我们会固定某些参数，只用某种特化的可调用对象。使用 std::bind 固定某些参数，其余参数使用用 std::placeholders 占位符占位即可实现。 #include \u003cfunctional\u003e ... // 函数：将任意进制的数转换为十进制数 int anyBaseToDecimal(const std::string\u0026 num, int base) { int decimalNum = 0; int power = 0; for (int i = num.size() - 1; i \u003e= 0; --i) { int digit = isdigit(num[i]) ? num[i] - '0' : num[i] - 'A' + 10; decimalNum += digit * pow(base, power); power++; } return decimalNum; } // 使用 std::bind 和 std::placeholders 构造特定进制转换的偏函数 int main() {std: // 绑定转换为二进制的偏函数 auto binaryConverter = std::bind(anyBaseToDecimal, std::placeholders::_1, 2); std::cout \u003c\u003c \"Binary to Decimal: \" \u003c\u003c binaryConverter(\"1010\") \u003c\u003c std::endl; // 绑定转换为十六进制的偏函数 auto hexConverter = std::bind(anyBaseToDecimal, :placeholders::_1, 16); std::cout \u003c\u003c \"Hexadecimal to Decimal: \" \u003c\u003c hexConverter(\"1A\") \u003c\u003c std::endl; return 0; } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:14:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"智能指针 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:15:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"new 操作符 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:16:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"placement new 允许在被指定位置构造对象，可以在栈、静态区等位置构建。 struct MyObject { int value; MyObject(int value) : value(value) ~MyObject() }; // Define a static buffer alignas(MyObject) static uint8_t buf[sizeof(MyObject)]; int main() { const MyObject* obj = new(buf) MyObject(42); // Placement new to construct object in buf // Use the object // For example, calling a member function obj-\u003e~MyObject(); // Explicitly call the destructor return 0; } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:16:1","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"转换（Conversions） ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:17:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"隐式转换 整型提升 Integer Promotion 规则： If an int can represent all values of the original type, the value is converted to an int; otherwise, it is converted to an unsigned int. These are called the integer promotions. All other types are unchanged by the integer promotions. —— C99 算术运算符不接受小于 int 的类型作为它的实参，而在左值到右值转换后，如果适用就会自动实施整数提升。此转换始终保持原值。进行这种转换的原因是 CPU 在处理其原生整数大小的整数时速度最快。 void cmp() { int16_t a = 30767; int16_t b = -32768; auto t1 = a - b; // 推导为 int if (a - b \u003c 0) ; // false if (static_cast\u003cint16_t\u003e(a - b) \u003c 0) ; // true if (a \u003c b) ; // false } 这个规则可以用于处理 tcp 序列号回绕问题，在 TCP 协议中，序列号是 32 位无符号整数，因此它们的范围是从 0 到 2^32-1。当序列号达到最大值时，它会回绕到 0。 // linux static inline int before(__u32 seq1, __u32 seq2) { return (__s32)(seq1 - seq2) \u003c 0; } #define after(seq2, seq1) before(seq1, seq2) // lwip #define TCP_SEQ_LT(a,b) ((s32_t)((u32_t)(a) - (u32_t)(b)) \u003c 0) 以上比较成立的前提是回绕的增量小于 2^31 - 1。类似的处理手法可以应用于环形缓冲区、计时器和时间戳、游戏开发中的坐标系统以及数据流处理中的窗口滑动等场景。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:17:1","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"显式转换 C++ 四种显式类型转换： static_cast 转换一个类型为另一相关类型 dynamic_cast 在继承层级中转换 const_cast 添加或移除 cv 限定符 reinterpret_cast 转换类型到无关类型 相比之下，C++ 的类型转换每次只转换类型的一个方面，C 风格的转换行为难以控制。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:17:2","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"字面量（Literals） 用以表现嵌入到源代码中的常量值的记号，主要有整数、字符、浮点、字符串、bool、nullptr 和用户定义字面量。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:18:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"分隔符（C++14） 数字之间可使用单引号分隔符，方便阅读，编译时会忽略： int a = 0b0001'1001'0001; double b = 3.141'5926'5358'9793'2385; 类似于 Python 3.6 中数字的下划线： a = 1_000_000 b = 3.68_796 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:18:1","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"用户定义字面量 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:18:2","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"initializer_list std::initializer_list\u003cT\u003e 类型的对象是轻量代理对象，在编译时创建 const T 的对象数组，提供迭代器和 size()。例如： #include \u003ciostream\u003e int main() { for (auto x : {\"hello\", \"coding\", \"world\"}) ; } 可通过 cppinsights 查看实际执行： #include \u003ciostream\u003e int main() { { const char *const __list4_19[3]{\"hello\", \"coding\", \"world\"}; std::initializer_list\u003cconst char *\u003e \u0026\u0026 __range1 = std::initializer_list\u003cconst char *\u003e{__list4_19, 3}; const char *const * __begin1 = __range1.begin(); const char *const * __end1 = __range1.end(); for(; __begin1 != __end1; ++__begin1) { const char * x = *__begin1; } } return 0; } 注意： std::initializer_list 是“视图”类型，主要用于传递函数参数，如果用作返回值则面临生命周期的问题。 编译时创建的 const T 分配在栈空间或者只读内存上。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:19:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"值类别 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:20:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"异常 一般认为，重要的构造函数、复制构造函数和移动构造函数应该尽量声明为 noexcept，析构函数则必须保证不抛出异常。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:21:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"参考 C-style array decay C-style string symbolic constants Microcontroller Embedded C Programming Lecture 143: Usage of const and volatile together What does a variable that is both const and volatile mean? Pass by address 复制初始化 Member functions returning references to data members 克服边界：在 C++ 中兼容 C 语言风格的函数指针回调的方式 使用 constexpr 时遇到的小坑 C++11 lambda 表达式与仿函数 仿函数 new expression 表达式 Deep C: Integer Promotion tcp 序列号回绕与解决 关于 lwip 中的 tcp 序列号防回绕（sequence wraparound）实现分析 字面量 C++14 更多新特性 std::initializer_list in C++ 1/2 - Internals and Use Cases ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:22:0","tags":null,"title":"[未完成] C++ 基本概念","uri":"/draft/cpp/c++-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"同步原语 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%B9%B6%E5%8F%91/:1:0","tags":null,"title":"[未完成] C++ 并发","uri":"/draft/cpp/c++-%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"posix 接口 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%B9%B6%E5%8F%91/:2:0","tags":null,"title":"[未完成] C++ 并发","uri":"/draft/cpp/c++-%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"modern C++ 并发支持 C++11 之后， ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%B9%B6%E5%8F%91/:3:0","tags":null,"title":"[未完成] C++ 并发","uri":"/draft/cpp/c++-%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"事件驱动 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%B9%B6%E5%8F%91/:4:0","tags":null,"title":"[未完成] C++ 并发","uri":"/draft/cpp/c++-%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":"协程 C++20 后， ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E5%B9%B6%E5%8F%91/:5:0","tags":null,"title":"[未完成] C++ 并发","uri":"/draft/cpp/c++-%E5%B9%B6%E5%8F%91/"},{"categories":null,"content":" SFINAE: Substitution Failure Is Not An Error，替换失败不是错误 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/:0:0","tags":null,"title":"[未完成] C++ 模板","uri":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"函数模板 从简单例子开始： template\u003ctypename T\u003e T max(const T\u0026 a, const T\u0026 b) { return a \u003e b ? a : b; } 如果调用时传入两个不同类型值，例如 max(1, 2.1);，可以使用如下方式修改。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/:1:0","tags":null,"title":"[未完成] C++ 模板","uri":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"方式一 直接通过默认模板参数指定一部分类型的实例化。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/:1:1","tags":null,"title":"[未完成] C++ 模板","uri":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"方式二 template\u003ctypename T1, typename T2, typename RT = decltype(true ? T1{} : T2{})\u003e // 不求值语境 RT max(const T1\u0026 a, const T2\u0026 b) { return a \u003e b ? a : b; } 其中三目运算符的部分是提取 T1, T2 的公共类型，且其中的 true, false 不影响推断出的类型。T1{} 和 T2{} 是临时的构造对象。例如： using Tx = decltype(true ? 1 : 1.2); using Ty = decltype(false ? int{} : double{}); 上面的表达式返回的类型都是 double。 或者直接使用 a, b，不使用临时对象，但是这种情况下 cv 限定符失效。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/:1:2","tags":null,"title":"[未完成] C++ 模板","uri":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"方式三 不需要定义 RT 类型名，后置返回类型 (C++14)，结合 auto 实现： template\u003ctypename T1, typename T2\u003e // a, b 不是临时对象 auto max(const T1\u0026 a, const T2\u0026 b) -\u003e decltype(true ? a : b) { return a \u003e b ? a : b; } [!NOTE] C++14 返回值推导中，auto 只是占位符。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/:1:3","tags":null,"title":"[未完成] C++ 模板","uri":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"方式四 C++ 20，全部使用 auto 推导： auto max(const auto\u0026 a, const auto\u0026 b) { return a \u003e b ? a : b; } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/:1:4","tags":null,"title":"[未完成] C++ 模板","uri":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"万能引用 万能引用，又叫转发引用。接受左值表达式形参就推导为左值表达式，接受右值表达式就被推导为右值表达式。 template\u003ctypename Ty\u003e constexpr Ty\u0026\u0026 forward(Ty\u0026 Arg) noexcept { return static_cast\u003cTy\u0026\u0026\u003e(Arg); } int a = 10; ::forward\u003cint\u003e(a); // 无引用折叠 int\u0026\u0026 ::forward\u003cint\u0026\u003e(a); // int\u0026 ::forward\u003cint\u0026\u0026\u003e(a); // int\u0026\u0026 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/:2:0","tags":null,"title":"[未完成] C++ 模板","uri":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"变量模板（C++14） ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/:3:0","tags":null,"title":"[未完成] C++ 模板","uri":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"Concepts（C++20） 给模板参数添加约束或者概念，例如定义一个模板函数，只有某个类及其派生类使用： #include \u003cconcepts\u003e #include \u003ctype_traits\u003e // 基类 A class A {}; // B 派生自 A class B : public A {}; // 不相关的类 C class C {}; // 定义一个 concept，检查 T 是否是 A 的派生类（包括 A 自己） template\u003ctypename T\u003e concept IsDerivedFromA = std::is_base_of\u003cA, T\u003e::value; // 使用 concept 约束的函数模板 template\u003cIsDerivedFromA T\u003e void myFunction(const T\u0026 obj) { std::cout \u003c\u003c \"Called with a type derived from A\\n\"; } int main() { A a; B b; C c; myFunction(a); // OK myFunction(b); // OK // myFunction(c); // 错误，C 不是 A 的派生类 return 0; } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/:4:0","tags":null,"title":"[未完成] C++ 模板","uri":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"相关技巧 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/:5:0","tags":null,"title":"[未完成] C++ 模板","uri":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"trait 一种仿 rust traits 的多态： struct Foo() { void print() const { std::cout \u003c\u003c __PRETTY_FUNCTION__ \u003c\u003c \"\\n\"; } }; struct Bar() { void print() const { std::cout \u003c\u003c __PRETTY_FUNCTION__ \u003c\u003c \"\\n\"; } }; template \u003ctypename T\u003e struct print_traits { using print_return_t = decltype(std::declval\u003cT\u003e().print()); }; template \u003ctypename T, typename traits = print_traits\u003cT\u003e\u003e auto print(const T \u0026obj) noexcept -\u003e typename traits::print_return_t { return obj.print(); } print_traits 是一个模板结构体，它接受一个类型 T，内部定义一个类型别名 print_return_t，使用 decltype 来推导 T 类型的 print 成员函数的返回类型。 std::declval() 返回一个类的右值引用，不需要实际创建对象，且对于无默认构造函数的类有效 -\u003e typename traits::print_return_t，表示函数的返回类型是 traits 中的 print_return_t 类型 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/:5:1","tags":null,"title":"[未完成] C++ 模板","uri":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"参考 现代 C++ 编程（一）：多态 理解 std::declval 理解 std::declval 和 decltype ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/:6:0","tags":null,"title":"[未完成] C++ 模板","uri":"/draft/cpp/c++-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"封装/类 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"访问权限 private 成员： private 私有成员，只能在定义该类的成员函数内部访问。对于类的外部不可见，外部对象无法直接访问，派生类也无法访问私有成员。 private 成员通常用于封装类的实现细节，隐藏内部实现，提高安全性和封装性。 protected 成员： protected 也是类的私有成员，具有更宽松的访问权限。可以被该类的成员函数和派生类的成员函数访问。外部对象无法直接访问。 protected 成员通常用于实现继承和派生类的访问控制。 保护是编译时的机制提供的，目标是防止意外事件，而不是防止欺骗或者有意入侵。 ———— 《C++ 语言的设计与演化》 可使用 using 改变 protected 成员在派生类中的访问权限，例如： #include \u003ciostream\u003e class Base { public: Base() {} protected: int m = 0; }; class Derived1 : public Base { public: int test() { return m; } }; class Derived2 : public Base { public: using Base::m; }; int main() { Derived1 d1; Derived2 d2; int x = d1.test(); // 只能通过成员函数访问 int y = d2.m; // 修改成了 public return 0; } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:1","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"成员函数 隐式内联 类内定义的成员函数隐式内联（因为一般这种定义会出现在头文件中，被多处包含），类外定义的成员函数非隐式内联。例如： class Entity { // implicitly inline void foo1() { std::cout \u003c\u003c \"foo1\" \u003c\u003c std::endl; } }; void foo2() { std::cout \u003c\u003c \"foo2\" \u003c\u003c std::endl; } 成员函数的 const const 修饰类的方法，表明该方法不会改变对象的状态，且能正确处理 const 对象的调用。 class Entity { private: int m_X; public: int GetX() { return m_X; } int GetX() const { return m_X; } void SetX(int x) { m_X = x; } }; void PrintEntity(const Entity\u0026 e) { std::cout \u003c\u003c e.GetX() \u003c\u003c std::endl; } 当使用常量左值引用传递对象时，const 保证了 GetX() 方法的调用是安全的。 const 成员函数可以被 const 和非 const 对象调用。所以如果类方法不会改变类的状态，尽量使用 const 修饰。 标准库中经常提供 const 和非 const 版本的重载，处理返回值在常量性方面的不同。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:2","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"static 成员变量 静态成员变量被该类的所有对象共享，是位于类的作用域区域内的全局变量，不与某个具体对象关联。可以通过类名和作用域解析运算符访问和初始化。 struct X { static int s_value; // 静态成员变量声明 }; int X::s_value{ 10 }; // 静态成员变量定义 int main() { X s; std::cout \u003c\u003c X::s_value \u003c\u003c std::endl; } ODR use : 一个对象在它的值被读取（除非它是编译时常量）或写入，或取它的地址，或者被引用绑定时，这个对象被 ODR 使用。 使用“所引用的对象在编译期未知”的引用时，这个引用被 ODR 使用。 一个函数在被调用或取它的地址时，被 ODR 使用。 如果一个对象、引用或函数被 ODR 使用，那么程序中必须有它的定义；否则通常会有链接时错误。 因此，在上面的例子中，如果没有在类外定义静态变量则编译时报错。 除此之外，静态成员变量可以直接在类内初始化： class X { public: static const int s_value1 { 4 }; // 这是 \"声明\" static inline int s_value2 { 5 }; // C++ 17, 定义 static constexpr int s_value3 { 6 }; // C++ 17 , 内联变量定义，constexpr 成员隐式内联 }; const int X::s_value1; // 需要此行 注意上方的 s_value1，这种方式下仍然属于声明，可以使用他的值，但取地址行为未定义（虽然部分编译器可能违反这条规则进而编译通过）。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:3","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"static 成员函数 在 C 中，static 使变量具备静态存储期，只初始化一次，具有内部链接（除非在块作用域）。 由于静态成员函数不与对象关联，所以默认参数无 *this 指针。静态成员函数可直接访问其他静态成员（变量或函数），不能访问非静态成员。这是因为非静态成员必须属于一个此类的对象，而静态成员函数没有类对象可供使用。 静态成员函数可以在类外定义，定义时不需要 static 修饰： class Log { private: static inline std::string str = \"Hello World\"; public: static void setStr(std::string\u0026\u0026 message); }; void Log::setStr(std::string\u0026\u0026 message) { str = message; std::cout \u003c\u003c str \u003c\u003c std::endl; } C++ 没有静态构造函数 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:4","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"友元 friend 声明在类体内，授予一个函数或类完整的访问权限。 构造函数与析构函数也可以是友元，友元关系不能传递，不能继承。 友元函数 某类的友元函数不是该类的成员函数 友元类 Attorney-Client Idioms 友元一定程度会破坏类的封装，增加耦合性，因为继承得到的类可能由不同人员或者组织开发，友元关系如果被继承会引入破坏性变更。 可以使用“律师 - 委托人”习语，实现友元的“继承”，通过增加一个间接级别来工作。一个客户端类想要控制对其内部细节的访问，它指定了一个代理人并使其成为 friend。Attorney 用作 Client 的代理。 下面的例子修改自 wiki 上的案例代码。 将 Attorney 类中的 callFunc 方法设为公有 #include \u003ciostream\u003e class Base { private: virtual void Func(int x) = 0; friend class Attorney; public: virtual ~Base() {} }; class Derived : public Base { private: virtual void Func(int x) { std::cout \u003c\u003c \"Derived::Func called with x = \" \u003c\u003c x \u003c\u003c std::endl; } public: ~Derived() {} }; class Attorney { public: // 将 callFunc 方法设为公有 static void callFunc(Base\u0026 b, int x) { return b.Func(x); } }; int main() { Derived d; Attorney::callFunc(d, 10); return 0; } 引入一个新的 Proxy 类，该类公开一个静态方法 callFunc，该方法内部调用 Attorney::callFunc。 #include \u003ciostream\u003e class Base { private: virtual void Func(int x) = 0; friend class Attorney; public: virtual ~Base() {} }; class Derived : public Base { private: virtual void Func(int x) { std::cout \u003c\u003c \"Derived::Func called with x = \" \u003c\u003c x \u003c\u003c std::endl; } public: ~Derived() {} }; class Attorney { private: static void callFunc(Base\u0026 b, int x) { return b.Func(x); } friend class Proxy; }; class Proxy { public: static void callFunc(Base\u0026 b, int x) { Attorney::callFunc(b, x); } }; int main() { Derived d; Proxy::callFunc(d, 10); return 0; } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:5","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"构造函数 构造函数没有名字且无法被直接调用。它们在发生初始化时被调用，且按照初始化的规则进行选择。 成员初始化： 对象实例化过程中，内存分配后，才会调用构造函数初始化对象的成员变量。 构造函数体内赋值 直接将变量赋值过程写在构造函数体中，不建议使用。函数体内赋值相比于成员初始化列表存在效率问题，例如： class Example { public: Example() { std::cout \u003c\u003c \"create example \" \u003c\u003c \"\\n\"; } Example(int x) { std::cout \u003c\u003c \"create example with \" \u003c\u003c x \u003c\u003c \"\\n\"; } }; class Entity { private: std::string m_Name; Example m_Example; public: Entity() : m_Name(\"Unknown\") { m_Example = Example(8); } // 打印两次 Entity() : m_Name(\"Unknown\"), m_Example(8) { } // 打印一次 }; Entity e; // Entity e(); // 警告 // Entity e{}; // OK 在进入构造函数的函数体之前，m_Example 进行了默认初始化。 在开始执行组成构造函数体的复合语句之前，所有直接基类、虚基类和非静态数据成员的初始化均已结束。 这里注意调用默认无参构造函数时，如果使用 Example e(); 编译器会出现警告：warning: empty parentheses interpreted as a function declaration [-Wvexing-parse]。这种写法和函数声明的写法存在歧义，变量 e 不能被正常构造，要去掉 () 或者使用 {}。 成员初始化器列表（勿和 initializer_list 混淆） 成员初始化器列表的构造顺序是按照类中成员变量声明的顺序，而非成员初始化器列表本身的顺序。 struct X { int i, j; X(int val) : j(val), i(j) { } // 先初始 i, 再初始 j }; 引用成员不能绑定到成员初始化器列表中的临时量： struct A { A() : v(42) {} // 错误 const int\u0026 v; }; 上面的代码在 gcc, msvc 下可以正常编译，clang 下才会提示：error: reference member ‘v’ binds to a temporary object whose lifetime would be shorter than the lifetime of the constructed object。这是由于在提案 CWG1696 前，构造函数的成员初始化器列表中可以绑定临时量到引用成员。但是这个临时量只持续到构造函数退出前，而非对象存在期间。 如果成员是 const、引用或未提供默认构造的类类型，必须使用成员初始化器列表。 class Base { public: Base(int a, int b) : m_a(a), m_b(b) // OK { // m_a = a; // error // m_b = b; // error } private: int\u0026 m_a; const int m_b; }; 委托构造函数 允许在构造函数初始化列表中调用另一个构造函数，委托完成部分初始化，定义委托构造时没有顺序要求，例如： class Person { private: std::string name; int age; public: Person() : Person(\"Unknown\", 0) {} Person(const std::string\u0026 name) : Person(name, 0) {} // 委托构造函数 Person(const std::string\u0026 name, int age) : name(name), age(age) {} }; Person person2(\"Alice\"); 前两个构造函数将都会委托给第三个构造函数完成实例化。 使用委托构造时不能使用构造函数的初始化列表： class class_a { public: class_a() {} // member initialization here, no delegate class_a(string str) : m_string{ str } {} //can't do member initialization here // error C3511: a call to a delegating constructor shall be the only member-initializer class_a(string str, double dbl) : class_a(str) , m_double{ dbl } {} // only member assignment class_a(string str, double dbl) : class_a(str) { m_double = dbl; } double m_double{ 1.0 }; string m_string; }; 使用委托构造时要注意防止形成环形构造。 默认构造函数 可以不带任何实参调用的构造函数是默认构造函数。 constexpr 构造 被 constexpr 修饰的构造函数会将该类型转为 LiteralType，令常量对象在编译期被构造，分配在 rodata 段。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:6","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"转换构造函数 不以说明符 explicit 声明的构造函数被称为转换构造函数（converting constructor）。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:7","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"析构函数 析构函数内定义对象被销毁前要执行的动作，例如回收堆内存，记录日志等。 RAII：资源获取即初始化（Resource Acquisition Is Initialization），将使用前请求的资源（堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥量、磁盘空间、数据库连接等——任何受限的资源）的生命周期与一个对象的生存期绑定。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:8","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"复制构造函数 可以接收同类型的另一对象为实参的构造函数是复制构造函数或移动构造函数。 浅拷贝： 深拷贝： ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:9","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"移动构造函数 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:10","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"this 指针 this 指针始终指向正在被操作的对象。当对某个对象调用非静态成员函数时，编译器会将该对象的地址作为隐藏的参数传递给函数。 myDate.setMonth( 3 ); // 等价于 setMonth( \u0026myDate, 3 ); 对象的 this 指针不是对象的一部分，他只是一个函数参数，所以不会影响 sizeof 语句的结果。 All non-static member functions have a this const pointer that holds the address of the implicit object. 用途： 显式调用 this 指针消除成员变量和同名参数的歧义 void PrintEntity(const Entity\u0026 e) { // print logic } class Entity { public: int x, y; Entity(int x, int y) { this-\u003ex; (*this).y = y; PrintEntity(*this); } }; 通过返回 this 指针实现链式调用，也用于实现 Named Parameter Idiom。 命名参数惯用法：C++ 函数参数有位置次序性的限制。因此通过方法链或者结构体的指示器语法实现命名参数。 class X { public: int a; char b; ... X \u0026 setA(int i) { a = i; return *this} // non-const function X \u0026 setB(char c) { b = c; return *this} static X create() { return X(); } }; // 使用 X::create().setB('Z').setA(10); 重置类的状态 void Reset() { *this = {}; } this 指针可以被 delete。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:11","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"继承 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:0","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"布局 class A { public: int x; protected: int y; private: int z; }; class B : public A {}; B 将得到 A 的全部元素，只是访问权限不同。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:1","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"继承类型 继承时也存在 private, protected 和 public 三种继承，前两种很少用到，默认是 private 继承。 class A {}; class B : public A {}; class C : private B {}; class D : protected C {}; class E : D {}; // private ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:2","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"虚函数 如果一个成员函数是虚函数，则派生类中匹配的重写都是虚函数。派生类中的虚函数重写不会隐式地让基类成员函数成为虚函数。 条款 9 : 不要从构造函数或析构函数调用虚函数。 rule 9 : Never call virtual functions during construction or destruction. —— Effective C++ 条款 36 : 绝不重新定义继承而来的 non-virtual 函数 rule 36 : Never redefine an inherited non-virtual function. —— Effective C++ 条款 37 : 绝不重新定义继承而来的缺省参数值 (virtual 函数) rule 37 : Never redefine a function’s inherited default parameter value. —— Effective C++ 创建派生类时首先调用基类构造函数，此时派生类还没有创建，无法调用派生类的虚函数版本。在基类析构函数中调用虚函数，它将始终解析为该函数的基类版本，因为派生部分已经被销毁。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:3","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"override and final 派生类虚函数只有当它的函数签名和返回类型完全匹配时才被认为是重写。 C++ Templates – the complete guides 签名： The unqualified name of the function The class or namespace scope of that name, and if the name has internal linkage, the translation unit in which the name is declared The const, volatile, or const volatile qualification of the function The types of the function parameters its return type, if the function is generated from a function template The template parameters and the template arguments, if the function is generated from a function template 如果函数具有不同的签名，则它们可以在程序中共存。普通函数的签名不包含返回类型。 因此在重写派生类的虚函数时可能会导致意外结果，例如下面两种情况会编译通过： class A { public: virtual std::string_view getName1(int x) { return \"A\"; } virtual std::string_view getName2(int x) { return \"A\"; } }; class B : public A { public: virtual std::string_view getName1(short x) { return \"B\"; } // note: parameter is a short virtual std::string_view getName2(int x) const { return \"B\"; } // note: function is const }; override 关键字用于虚函数后，明确表示此处重写基类中的虚函数，不匹配则编译失败： class A { public: virtual std::string_view getName1(int x) { return \"A\"; } virtual std::string_view getName2(int x) { return \"A\"; } virtual std::string_view getName3(int x) { return \"A\"; } }; class B : public A { public: std::string_view getName1(short int x) override { return \"B\"; } // compile error, function is not an override std::string_view getName2(int x) const override { return \"B\"; } // compile error, function is not an override std::string_view getName3(int x) override final { return \"B\"; } // okay, function is an override of A::getName3(int) }; 对于派生类的覆写函数使用 override 说明符，包括虚析构。 final 说明符用于表示此虚函数不再允许被覆写。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:4","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"纯虚函数 virtual std::string speak() const = 0; 任何具有一个或多个纯虚函数的类都会变成抽象基类，不能被实例化。它要求派生类必须重写此成员函数，否则此派生类也会被认为是抽象类。 抽象类具有虚表 任何具有纯虚函数的类都应该具有虚析构函数 没有成员变量，全部有虚函数组成的类被称为接口类，对应其他语言的接口类 interface 的概念 可以为纯虚函数在类外提供定义。– C++ Primer 如果要为抽象类提供纯虚函数的默认实现（很少用到），在类外定义虚函数的实现，并在派生类中显式通过作用域运算符调用： class Animal { protected: std::string m_name {}; public: Animal(std::string_view name) : m_name(name) { } const std::string\u0026 getName() const { return m_name; } virtual std::string speak() const = 0; virtual ~Animal() = default; }; // 定义默认版本 std::string Animal::speak() const { return \"buzz\"; } class Dragonfly: public Animal { public: Dragonfly(std::string_view name) : Animal{name} { } std::string speak() const override { return Animal::speak(); // 使用默认实现 } }; 作用域解析运算符同时可用于区分继承类中的同名函数： class Base { private: int m_value {}; public: Base(int value) : m_value{ value } { } void identify() const { std::cout \u003c\u003c \"Base\\n\"; } }; class Derived: public Base { public: Derived(int value) : Base { value } { } void identify() const { Base::identify(); // call Base::identify() std::cout \u003c\u003c \"Derived\\n\"; // then identify ourselves } }; ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:5","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"虚析构 在析构函数未使用 virtual 修饰的情况下，使用基类类型的指针创建一个派生类对象，那么派生类析构时只会调用基类的析构函数。 条款 7 : 为多态基类声明 virtual 析构函数 rule 7 : Declare destructors virtual in polymorphic base classes. —— Effective C++ ... class Base { public: virtual ~Base() { std::cout \u003c\u003c \"Base destructor called\" \u003c\u003c std::endl; } }; class Derived : public Base { public: ~Derived() { std::cout \u003c\u003c \"Derived destructor called\" \u003c\u003c std::endl; } }; int main() { Base* ptr = new Derived(); delete ptr; // 如果 Base 的析构函数不是虚函数，只会调用 Base 的析构函数 return 0; } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:6","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"多重继承 尽量避免使用多重继承，因为要处理菱形继承问题。 假设 B、C 都继承自 A，D 继承自 B 和 C，不使用虚继承的情况下 D 会得到 A 类的两个副本。虚继承用于解决此类问题。 class A { }; class B: virtual public A { }; class C: virtual public A { }; class D: public B, public C { }; 此时，“最派生\"的类负责构造虚基类 A ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:7","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"多态 C++ 的虚函数是实现多态性的一种方法，也可以使用模板、函数指针等方法实现。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:0","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"绑定的概念 绑定指将标识符 (如变量和函数名) 转换为地址的过程。分为静态绑定和动态绑定。 Early Binding (compile-time time polymorphism) As the name indicates, compiler (or linker) directly associate an address to the function call. Late Binding : (Run time polymorphism) In this, the compiler adds code that identifies the kind of object at runtime then matches the call with the right function definition. This can be achieved by declaring a virtual function. ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:1","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"RTTI 机制 Run-Time Type Identification, 用于在程序运行时获取对象的类型信息，主要包括 typeid 和 dynamic_cast 运算符。 注意：某些 dynamic_cast 需要 RTTI，但是另一些实现选择在编译时完成，不依赖 RTTI。参考 cppreference 和 Itanium C++ ABI typeid 和 decltype： typeid 在运行时获取类型信息，返回 type_info 对象，用于动态类型识别。 decltype 在编译时获取类型信息，用于类型推断、声明变量类型、模板编程等。decltype 读作 “declare type”。 typeid 使用 typeid 运行时获取类型信息，但是返回的结果是实现定义的。其中 MSVC、IBM、Oracle 编译期会生成人类可读的类型名，gcc 与 clang 返回重整名（mangled name），这是由于二者采用 Itanium C++ ABI。 Itanium C++ ABI: 最早是为 Intel 的安腾（Itanium）架构编写的，是一个跨架构的 C++ ABI。上世纪 90 年代，GCC 编译器通过使用 setjmp 和 longjmp 实现了 C++ 异常处理。出于多种原因，这是不能令人满意的。Intel 生产 Itanium 时，他们希望允许 GCC 和英特尔编译器 icc 进行互操作，包括在两个编译器编译的代码之间抛出异常。他们成立了一个工作组来设计一个 ABI 来支持这一点，包括一种不使用 longjmp 的异常处理方法。 MSVC 不使用 Itanium C++ ABI C++ ABI 主要规定： 函数传参方式 虚函数机制 struct / class 内存布局 name mangling RTTI 和异常 重整名可以用实现指定的 API 转换到人类可读的形式，例如： #include \u003ctypeinfo\u003e // 提供 typeid #include \u003ccxxabi.h\u003e #include \u003cmemory\u003e #include \u003ccstdlib\u003e std::string demangle(const char* name) { int status = -1; std::unique_ptr\u003cchar, void(*)(void*)\u003e res { abi::__cxa_demangle(name, NULL, NULL, \u0026status), std::free }; return (status==0) ? res.get() : name ; } // 使用 std::cout \u003c\u003c demangle(typeid(obj).name()) \u003c\u003c std::endl; 也可以使用 c++filt -t 命令还原类型名： \u003e c++filt -t 4BaseI8Derived1E Base\u003cDerived1\u003e c++fit 用于还原由于名字重整（name mangling）机制的名称。例如使用 nm 列出二进制文件的符号表后，还原符号 _ZN4BaseI8Derived2E9interfaceEv： c++filt _ZN4BaseI8Derived2E9interfaceEv Base\u003cDerived2\u003e::interface() dynamic_cast 沿继承层级向上、向下及侧向，安全地转换到其他类的指针和引用。主要有下面三种用法： // type 必须是类类型 dynamic_cast\u003ctype*\u003e(e) // e 必须是指针 dynamic_cast\u003ctype\u0026\u003e(e) // e 必须是左值 dynamic_cast\u003ctype\u0026\u0026\u003e(e) // e 非左值 如果转换失败且目标类型是指针，则返回该类型的空指针。如果转换失败且目标类型是引用类型，则会抛出与类型 std::bad_cast 的处理块匹配的异常。 static_cast 也能用来进行向下转换，不会有运行时检查的开销，但只有在程序（通过其他逻辑）能够保证表达式指向的对象肯定是 Derived 时才是安全的。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:2","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"对象切片 当使用基类类型，利用拷贝初始化的方式实例化派生类对象时，会发生切片现象。基类无法容纳派生类的所有成员。以下面代码为例： class Base { private: int a, b; public: Base(int _a, int _b) : a(_a), b(_b) {} virtual void foo() const {} }; class Dev1 : public Base { private: bool c; public: Dev1(int _a, int _b, bool _c) : Base(_a, _b), c(_c) {} void foo() const { std::cout \u003c\u003c \"Dev1 foo\" \u003c\u003c \"\\n\"; } }; class Dev2 : public Base { private: bool c; public: Dev2(int _a, int _b, bool _c) : Base(_a, _b), c(_c) {} void foo() const { std::cout \u003c\u003c \"Dev2 foo\" \u003c\u003c \"\\n\"; } }; void fooPrint(const Base\u0026 b) { b.foo(); } int main() { Base b1 = Dev1(1, 2, true); // 发生切片 const Base\u0026 b2 = Dev1(2, 3, true); // 给派生类创建基类引用，对象未被切片，但能通过引用使用的变量和函数不全 b2.foo(); // 多态实现 const Base\u0026 d1 = Dev1(3, 5, true); const Base\u0026 d2 = Dev2(9, 4, false); fooPrint(d1); fooPrint(d2); return 0; } 可以使用基类的引用实现多态性。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:3","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"C 数组多态问题 条款 3 : 绝对不要以多态方式处理数组 —— More Effective C++ struct BST { char c; }; struct balancedBST : public BST { int x; }; void printBSTArray(const BST array[], int numElements) { for(int i = 0; i \u003c numElements; i++) std::cout \u003c\u003c array[i].c \u003c\u003c \" \"; std::cout \u003c\u003c \"\\n\"; } array[i] 其实是 *(array + i) 的简写，每次移动距离为 i * sizeof(obj)，由于基类和派生类内存布局不同，因此行为异常。 同时，通过基类指针删除一个派生类构成的数组，行为未定义。 Base* pBase = new Derived[10]; delete[] pBase; ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:4","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"模板多态 使用模板实现编译期多态： struct Foo() { void print() const { std::cout \u003c\u003c __PRETTY_FUNCTION__ \u003c\u003c \"\\n\"; } }; struct Bar() { void print() const { std::cout \u003c\u003c __PRETTY_FUNCTION__ \u003c\u003c \"\\n\"; } }; typename \u003ctypename T\u003e auto print(const T \u0026 obj) { return obj.print(); } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:5","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"运算符重载 运算符可以被重载为成员函数和友元函数。 以下面的简单 String 为例子说明，运行： class String { private: char * data_; size_t len_; public: String() : data_(new char[1]), len_(0) { *data_ = '\\0'; } String(const char* str) : data_(new char[strlen(str) + 1]), len_(strlen(str)) { strcpy(data_, str); } String (const String\u0026 rhs) : data_(new char[rhs.len_ + 1]), len_(rhs.len_) { strcpy(data_, rhs.c_str()); } ~String() { delete[] data_; } const char* c_str() const { return data_; } void swap(String\u0026 rhs) { std::swap(data_, rhs.data_); } size_t size() const { return len_; } String\u0026 operator=(String rhs) { swap(rhs); return *this; } const char operator[](const size_t index) const { return *(data_ + index); } bool operator==(const String\u0026 rhs) const { return !strcmp(data_, rhs.data_); } bool operator!=(const String\u0026 rhs) const { return !(*this == rhs); } bool operator\u003c(const String\u0026 rhs) const { if (strcmp(data_, rhs.data_) \u003c 0) return true; else return false; } bool operator\u003e(const String\u0026 rhs) const { return (rhs \u003c *this); } bool operator\u003c=(const String\u0026 rhs) const { return !(*this \u003e rhs); } bool operator\u003e=(const String\u0026 rhs) const { return !(*this \u003c rhs); } friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const String\u0026 rhs) { os \u003c\u003c rhs.c_str(); return os; } }; ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:0","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"限制 不能重载 ::（作用域解析）、.（成员访问）、.*（通过成员指针的成员访问 a.*b）及 ?:（三目条件）运算符。 不能创建新运算符，例如 **、\u003c\u003e 或 \u0026|。 无法改变运算符的优先级、结合方向或操作数的数量。 重载的运算符 -\u003e 必须要么返回裸指针，要么（按引用或值）返回同样重载了运算符 -\u003e 的对象。 运算符 \u0026\u0026 与 || 的重载会失去短路求值。 \u0026\u0026、|| 和 ,（逗号）在被重载时失去它们特殊的定序性质，并且即使不使用函数调用记法，也表现为与常规的函数调用相似。 条款 7：千万不要重载 \u0026\u0026、|| 和 , 操作符 —— More Effective C++ 一些资料中也提到了不能重载 sizeof。 不是所有运算符都可以重载为友元函数： 赋值 = 、下标 [] 、函数调用 () 和成员选择 -\u003e运算符必须重载为成员函数 (历史原因)。 不是所有运算符都可以重载为成员函数： 通常，如果左操作数不是类（例如 int），或者是不能修改的类（例如 std：：ostream），无法使用成员重载。 经验法则： 赋值 = 、下标 [] 、函数调用 () 或成员选择 -\u003e，作为成员函数重载。 一元运算符，作为成员函数重载。 对不修改其左操作数的二元运算符（例如 operator+），作为一个普通函数（首选）或友元函数重载。 对修改左操作数的二元操作符，但你不能向左操作数的类定义添加成员（例如 operator«，左操作数 ostream），作为普通函数（首选）或友元函数重载。 对修改左操作数的二元运算符（例如 operator+=），并且可以修改左操作数的定义，作为一个成员函数重载。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:1","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"opeartor= 自我赋值问题 条款 10 : 令 operator= 返回一个 reference to *this rule 10 : Have assignment operators return a reference to *this. —— Effective C++ 条款 11 : 在 operator= 中处理“自我赋值” rule 11 : Handle assignment to self in operator=. —— Effective C++ copy-and-swap idiom TODO: ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:2","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"C++20 \u003c=\u003e 运算符 对于比较运算符的重载，一般只需要想明白 operator== 和 operator\u003c，其他情况可以由此推导出。 operator== 取反即为 operator!=。operator\u003c 取反即为 operator\u003e=。 实现了 operator\u003c 后，交换 *this 和 rhs 便可实现 operator\u003e。 注意 6 个重载需要 const，常见的错误是：error: passing ‘const xxx’ as ‘this’ argument discards qualifiers [-fpermissive]。 bool operator==(const String\u0026 rhs) const { return !strcmp(data_, rhs.data_); } bool operator!=(const String\u0026 rhs) const { return !(*this == rhs); } bool operator\u003c(const String\u0026 rhs) const { if (strcmp(data_, rhs.data_) \u003c 0) return true; else return false; } bool operator\u003e(const String\u0026 rhs) const { return (rhs \u003c *this); } bool operator\u003c=(const String\u0026 rhs) const { return !(*this \u003e rhs); } bool operator\u003e=(const String\u0026 rhs) const { return !(*this \u003c rhs); } 为了简化比较运算符，C++20 引入了 operator\u003c=\u003e 运算符。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:0","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"相关设计模式 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:0","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"组合 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:1","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"委托 一个对象委托另一个对象执行特定的任务或操作。一般通过包含委托类指针或者引用实现。 #include \u003ciostream\u003e // 委托类 class Delegate { public: void doTask() { std::cout \u003c\u003c \"Delegate is performing the task.\" \u003c\u003c std::endl; } }; // 委托对象 class Delegator { private: Delegate* delegate; public: Delegator(Delegate* del) : delegate(del) {} void assignTask() { if (delegate) { delegate-\u003edoTask(); // 通过指针委托给 Delegate 对象执行任务 } else { std::cout \u003c\u003c \"No delegate assigned.\" \u003c\u003c std::endl; } } }; int main() { Delegate delegate; Delegator delegator(\u0026delegate); delegator.assignTask(); // 修改委托对象 Delegate anotherDelegate; delegator = Delegator(\u0026anotherDelegate); delegator.assignTask(); return 0; } ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:2","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"NVI 惯用法 令用户通过 public non-virtual 成员函数间接调用 private virtual 函数，称为 non-virtual interface 手法。一种实现 Template Method 设计模式（和 C++ Template 语言机制无关）。 —— Effective C++ ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:3","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"pimpl ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:4","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"奇异递归模板模式 CRTP CRTP 可用于在基类暴露接口而派生类实现该接口时实现“编译期多态”。 // 基类模板 template \u003ctypename Derived\u003e class Base { public: void interface() { // 下转型 static_cast\u003cDerived*\u003e(this)-\u003eimpl(); } void impl() { std::cout \u003c\u003c \"Base\" \u003c\u003c std::endl; } }; // 派生类 1 class Derived1 : public Base\u003cDerived1\u003e { public: void impl() { std::cout \u003c\u003c \"Derived1\" \u003c\u003c std::endl; } }; // 派生类 2 class Derived2 : public Base\u003cDerived2\u003e { public: void impl() { std::cout \u003c\u003c \"Derived2\" \u003c\u003c std::endl; } }; // 多态 func template\u003ctypename T\u003e void func(Base\u003cT\u003e\u0026 base) { base.interface(); } int main(int argc, char* argv\u003c::\u003e) { Derived1 d1; Derived2 d2; func(d1); func(d2); return 0; } 注意，这种方式需要在基类中向派生类添加功能，被称为颠倒继承（Upside Down Inheritance），和传统的实现多态方式相反。 CRTP 能避免虚函数开销，实现编译时的静态多态性。但是编译后的二进制文件可能变大。采用 hands on design patterns with c++ 第八章代码进行性能测试，参见测压结果，CRTP 的性能需要打开优化后体现。 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:5","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"Mixin 继承 ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:6","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"参考 Member functions Const class objects and const member functions 定义与 ODR（单一定义规则） 友元声明 Why does C++ not allow inherited friendship? 引用初始化 编译期对象构造优化 .bss 为 .rodata 转换构造函数 委托构造函数 C++11 新语法之委托构造函数 深入探索 C++ 多态 - 虚析构 成员列表的作用 C++ 面向对象拓展 this 指针 15.1 — The hidden “this” pointer and member function chaining Virtual functions and polymorphism Is the return type part of the function signature? 第 18 篇：C++ 静态绑定和动态绑定 object slicing Pure virtual functions, abstract base classes, and interface classes C++ RTTI dynamic_cast 转换 Itanium C++ ABI new C++ 面试中 STRING 类的一种正确写法 “C++ 的数组不支持多态”？ Why is it undefined behavior to delete[] an array of derived objects via a base pointer? 运算符重载 Overloading operators using member functions Dynamic polymorphism: the non-virtual interface design pattern Design Patterns VS Design Principles: Template Method Design Patterns With C++（八）CRTP（上） ","date":"2024-02-25","objectID":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:7:0","tags":["C++"],"title":"[未完成] C++ 面向对象","uri":"/draft/cpp/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["VScode"],"content":"1. Json 文件 JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，最初由 Douglas Crockford 提出，作为 JavaScript 中对象字面量的一种表示方式，但已经成为一种独立于语言的格式。JSON 格式易于阅读和编写，同时也易于解析和生成。 优势： 易读性 易解析性 轻量级 支持复杂数据结构 使用场景： 配置文件 API 响应 日志数据 Web 开发 基本语法： 对象（Object）：使用花括号 {} 表示，键值对之间使用冒号分隔，键值对之间使用逗号分隔。例如：{“name”: “John”, “age”: 30} 数组（Array）：使用方括号 [] 表示，数组元素之间使用逗号分隔。例如：[1, 2, 3, 4, 5] 字符串（String）：使用双引号 \"\" 表示。例如：“Hello, World” 数字（Number）：可以是整数或浮点数。例如：10 或 3.14 布尔值（Boolean）：true 或 false 空值（null）：null 这个 JSON 表示一个包含个人信息的对象，包括姓名、年龄、是否是学生、所修课程和地址等。 { \"name\": \"John\", \"age\": 30, \"isStudent\": false, \"courses\": [\"Math\", \"Science\", \"History\"], \"address\": { \"street\": \"123 Main St\", \"city\": \"Anytown\" } } 大部分 VSCode 配置文件全部在 .vscode 文件夹下。一般有 launch.json，tasks.json，setting.json 和 xxx.code-snippets 等。JSON 是 Visual Studio Code 中大多数配置文件的首选格式，在 VSCode 中允许使用注释，带有自动提示。 ","date":"2023-12-23","objectID":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:1:0","tags":["VScode"],"title":"VSCode 配置文件和文档生成","uri":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["VScode"],"content":"2. 代码片段 Snippets xxx.code-snippets 文件用于项目的自定义代码片段。例如对于 C/C++ 项目可设置如下定义： //custom.code-snippets { \"Create Header Guard\": { \"prefix\": \"ifndef\", \"scope\": \"c\", \"body\": [ \"#ifndef ${1:HEADER_NAME_H_}\", \"#define ${1:HEADER_NAME_H_}\", \"\", \"// Your code here\", \"\", \"#endif // ${1:HEADER_NAME_H_}\" ], \"description\": \"Create a header guard\" }, \"Class Declaration\": { \"prefix\": \"class\", \"scope\": \"cpp\", \"body\": [ \"class ${1:ClassName} {\", \"public:\", \"\\t${1:ClassName}() {\", \"\\t\\t// Constructor code here\", \"\\t}\", \"\\t~${1:ClassName}() {\", \"\\t\\t// Destructor code here\", \"\\t}\", \"};\" ], \"description\": \"Class declaration template\" }, \"For Loop\": { \"prefix\": \"for\", \"scope\": \"c, cpp\", \"body\": [ \"for (int ${1:i} = 0; ${1:i} \u003c ${2:condition}; ++${1:i}) {\", \"\\t// Your code here\", \"}\" ], \"description\": \"For loop template\" }, \"Doxygen Comment\": { \"prefix\": \"comment\", \"scope\": \"c, cpp\", \"body\": [ \"/**\", \" * @brief ${1:brief description}\", \" * @date ${CURRENT_YEAR}.${CURRENT_MONTH}.${CURRENT_DATE}\", \" * @param ${2:param_name} ${3:Param description}\", \" * @param ${4:param_name} ${5:Param description}\", \" * @return ${6:return_type} ${7:Return description}\", \" */\" ], \"description\": \"Doxygen style comment\" } } 编辑一条 snippet 包含下面几个部分： “prefix” 表示输入哪些字符后弹出提示 “scope” 设置在哪些类型的文件中生效 “body” 代码片段内容 “description” 相当于注释，描述这个片段的作用 符号 ${digital} 代表产生片段后，光标的插入点，后面的数字代表按下 tab 后光标跳转的顺序。 如果是 ${digital:word} 则表示跳转到此处时 word 会被选中。 ${CURRENT_YEAR}.${CURRENT_MONTH}.${CURRENT_DATE} 能自动填充时间 可以使用 snippet-generator 辅助生成代码片段。 ","date":"2023-12-23","objectID":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:2:0","tags":["VScode"],"title":"VSCode 配置文件和文档生成","uri":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["VScode"],"content":"3. 任务 Tasks `tasks.json`` 机制旨在解决开发过程中的自动化任务管理问题。 自定义任务的集成：通过 tasks.json，开发者可以集成各种自定义的任务，比如编译、运行测试、代码质量检查等，以及任何其他可以通过命令行执行的任务。这样，开发者可以在 Visual Studio Code 中统一管理和执行这些任务，而无需离开编辑器。 跨平台的任务配置：tasks.json 支持在一个配置文件中定义跨平台的任务，因为它可以使用不同的命令和参数来适应不同的操作系统。这样，开发者可以在不同的操作系统上使用相同的配置文件来定义任务，而不需要为每个操作系统都单独配置任务。 问题匹配器的集成：tasks.json 支持配置问题匹配器，这使得开发者可以定义任务输出的格式，并将输出中的错误、警告等信息映射到 Visual Studio Code 中的问题列表，从而更轻松地查看和处理任务输出中的问题。 例如将圈复杂度检查工具 lizard 集成到 VSCode 的任务中。 { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"lizard\", \"type\": \"shell\", \"command\": \"lizard \\\"${file}\\\"\", \"group\": { \"kind\": \"none\", \"isDefault\": true }, \"presentation\": { \"reveal\": \"always\", \"panel\": \"new\" }, \"problemMatcher\": [] } ] } 编辑一个 task 包含下面几个部分： label：任务的标签，用于在 Visual Studio Code 中显示任务的名称。 type：任务的类型，通常是 “shell”，表示该任务是通过 shell 命令来执行的。 command：要执行的命令，可以包含变量（如 ${file}）来表示文件路径等信息。 group：任务分组信息，包括 kind 和 isDefault 两个属性。kind 属性用于指定任务的分组类型，例如 “build”、“test” 等，而 isDefault 属性用于指示该任务是否为默认任务。 presentation：任务的呈现（presentation）信息，包括 reveal 和 panel 两个属性。reveal 属性指定任务执行时是否自动显示输出，而 panel 属性指定任务输出的面板类型。 problemMatcher：问题匹配器信息，用于定义任务输出中错误、警告等信息的匹配规则。 任务编辑完成后，使用快捷键 Ctrl+Shift+P 输入 tasks，选择\"运行任务\"，即可看到刚才设置的任务。 ","date":"2023-12-23","objectID":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:3:0","tags":["VScode"],"title":"VSCode 配置文件和文档生成","uri":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["VScode"],"content":"4. 调试 launch VSCode 的调试配置信息被放置于 launch.json 中。C/C++ gdb 的配置： { \"configurations\": [ { \"name\": \"(gdb) 启动\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/build/demo\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}/build/\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"gdb\", \"setupCommands\": [ { \"description\": \"为 gdb 启用整齐打印\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true }, { \"description\": \"将反汇编风格设置为 Intel\", \"text\": \"-gdb-set disassembly-flavor intel\", \"ignoreFailures\": true } ] } ], \"version\": \"2.0.0\" } ","date":"2023-12-23","objectID":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:4:0","tags":["VScode"],"title":"VSCode 配置文件和文档生成","uri":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["VScode"],"content":"5. 工作区设置 settings settings.json 是 Visual Studio Code 中用于配置编辑器外观，行为和功能的文件。例如编写本文时的配置： { // 不从下列目录中搜索关键词 \"search.exclude\": { \"themes/\":true, \"public/\":true }, // 不显示的文件/文件夹 \"files.exclude\": { \"themes/\":true, \"public/\":true }, // 目录布局方式 \"workbench.tree.enableStickyScroll\":true } ","date":"2023-12-23","objectID":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:5:0","tags":["VScode"],"title":"VSCode 配置文件和文档生成","uri":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["VScode"],"content":"6. Doxygen 注释生成 安装 VSCode 插件 Doxygen Documentation Generator。在设置中搜索 doxygen 修改 author 和 email 字段。输入 /** 回车可自动产生符合 doxygen 的注释。生成的注释会根据后面的函数或者文件位置来判断。 ","date":"2023-12-23","objectID":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:6:0","tags":["VScode"],"title":"VSCode 配置文件和文档生成","uri":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["VScode"],"content":"7. VSCode Portable Mode VSCode 也提供解压即用的版本 Portable Mode，这个版本解压后进入解压的顶层目录，创建 data 文件夹，这样打开 VSCode 后，安装的插件和配置文件都会保存在这个文件夹中，更新时只需要替换其他部分即可。 缺点是不能正常使用右键菜单，可以通过修改注册表解决： Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell\\VSCode] @=\"Open with Code\" \"Icon\"=\"E:\\\\VSCode\\\\Code.exe\" [HKEY_CLASSES_ROOT\\*\\shell\\VSCode\\command] @=\"\\\"E:\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\" Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\shell\\VSCode] @=\"Open with Code\" \"Icon\"=\"E:\\\\VSCode\\\\Code.exe\" [HKEY_CLASSES_ROOT\\Directory\\shell\\VSCode\\command] @=\"\\\"E:\\\\VSCode\\\\Code.exe\\\" \\\"%V\\\"\" Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\VSCode] @=\"Open with Code\" \"Icon\"=\"E:\\\\VSCode\\\\Code.exe\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\VSCode\\command] @=\"\\\"E:\\\\VSCode\\\\Code.exe\\\" \\\"%V\\\"\" ","date":"2023-12-23","objectID":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:7:0","tags":["VScode"],"title":"VSCode 配置文件和文档生成","uri":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["VScode"],"content":"8. VSCode Profile VSCode Profile 功能允许用户创建自定义设置的集合，包括插件、快捷键、设置等，可以快速切换项目或语言环境并与他人共享。 点击：管理（左下角齿轮）–\u003e 配置文件 –\u003e 创建配置文件，根据提示命名和选择需要导出的系列设置，可以保存为 xxx.code-profile 文件。 ","date":"2023-12-23","objectID":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:8:0","tags":["VScode"],"title":"VSCode 配置文件和文档生成","uri":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["VScode"],"content":"参考 VSCode Snippets：提升开发幸福感的小技巧 Snippets in Visual Studio Code Integrate with External Tools via Tasks 使用 Doxygen 构建文档 Doxygen 笔记 Quick setup to use Doxygen with CMake Profiles in Visual Studio Code ","date":"2023-12-23","objectID":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:9:0","tags":["VScode"],"title":"VSCode 配置文件和文档生成","uri":"/vscode-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"TODO: 本文内容拆分到其他主题 ","date":"2023-12-20","objectID":"/draft/cpp/cpp-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/:0:0","tags":["C++"],"title":"[未完成] CPP_阅读记录","uri":"/draft/cpp/cpp-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"},{"categories":["C++"],"content":"C++ 语言的设计和演化 ","date":"2023-12-20","objectID":"/draft/cpp/cpp-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/:1:0","tags":["C++"],"title":"[未完成] CPP_阅读记录","uri":"/draft/cpp/cpp-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"},{"categories":["C++"],"content":"C++ 之旅 TODO: 拆分到 “语法” ","date":"2023-12-20","objectID":"/draft/cpp/cpp-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/:2:0","tags":["C++"],"title":"[未完成] CPP_阅读记录","uri":"/draft/cpp/cpp-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"},{"categories":["C++"],"content":"chapter 15 指针和容器 多个指针可以指向同一个对象，拥有所有权的指针负责删除他指向的对象。没有所有权的指针可以悬空，所以没有所有权的指针允许成为野指针。 unique_ptr 唯一所有权，析构函数负责销毁对象。和内置指针相比，unique_ptr 是一种没有时间或空间开销的轻量级机制。 shared_ptr 共享所有权，最后一个共享的析构函数负责销毁对象。shared_ptr 提供了某种形式的垃圾回收，确保确实需要共享所有权时才使用。 tuple 中具有唯一类型的元素可以通过其类型被访问。 tuple\u003cstring, int, double\u003e t1 {\"shark\", 123, 3.14}; // 方式 1 string fish = get\u003c0\u003e(t1); int count = get\u003c1\u003e(t1); double price = get\u003c2\u003e(t1); // 方式 2 auto fish = get\u003cstring\u003e(t1); auto count = get\u003cint\u003e(t1); auto price = get\u003cdouble\u003e(t1); ","date":"2023-12-20","objectID":"/draft/cpp/cpp-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/:2:1","tags":["C++"],"title":"[未完成] CPP_阅读记录","uri":"/draft/cpp/cpp-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"},{"categories":["C++"],"content":"C++ Core Guidelines ","date":"2023-12-20","objectID":"/draft/cpp/cpp-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/:3:0","tags":["C++"],"title":"[未完成] CPP_阅读记录","uri":"/draft/cpp/cpp-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"},{"categories":["C++"],"content":"视频参考 [隐式转换] class Entity { private: std::string m_Name; int m_Age; public: // explicit Entity(const std::string\u0026 name) Entity(const std::string\u0026 name) : m_Name(name), m_Age(8) { } // explicit Entity(int age) Entity(int age) : m_Name(\"Unknown\"), m_Age(age) { } }; // 合法 一次隐式转换为 Entity, 通过 explicit 禁用 Entity a = std::string(\"maze\"); Entity b = 22; // 隐式转换 Entity b = (Entity)22; // 显式转换 ","date":"2023-12-20","objectID":"/draft/cpp/cpp-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/:4:0","tags":["C++"],"title":"[未完成] CPP_阅读记录","uri":"/draft/cpp/cpp-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"},{"categories":["其他"],"content":"1. PowerShell 7 微软的 powershell 更新到 7 之后的版本终于让终端比较流畅，并且支持自动补全历史命令记录。安装后使用一下命令产生配置文件： echo $PROFILE 一般会生成在 C:\\Users\\{username}\\Documents\\PowerShell\\Microsoft.PowerShell_profile.ps1 下，通过编辑此文件配置终端命令。例如设置 function，作用类似于 linux 下的 alias。 语法：function 别名 { 被替代的命令 } function s {fastfetch} function c {clear} function q {exit} 如果被替代的命令在环境变量中就无需填写绝对路径。 ","date":"2023-12-14","objectID":"/%E5%90%84%E7%A7%8D-shell-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:1:0","tags":["其他"],"title":"各种 Shell 的配置文件","uri":"/%E5%90%84%E7%A7%8D-shell-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["其他"],"content":"2. Zsh / Bash Linux 终端的 shell 主流是 bash 和 zsh，二者配置文件编辑方式基本相同。推荐使用 zsh 和 oh-my-zsh。 安装 zsh 和 oh-my-zsh 后，配置 ~/.zshrc配置命令。需要安装命令行语法高亮、补全和跳转工具 (autojump) git clone https://github.com/zdharma-continuum/fast-syntax-highlighting.git \\ ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/fast-syntax-highlighting git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions ... plugins=(git history history-substring-search zsh-autosuggestions fast-syntax-highlighting autojump ) ... alias c='clear' alias ra='ranger' alias s='fastfetch' alias q='exit' alias ls='lsd' alias ll='lsd -l' alias vim='nvim' # python 添加 pip3 安装可执行文件位置 export PATH=/home/kali/.local/bin/:$PATH # fcitx5 export XMODIFIERS=@im=fcitx export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx # rust export RUSTUP_DIST_SERVER=\"https://rsproxy.cn\" export RUSTUP_UPDATE_ROOT=\"https://rsproxy.cn/rustup\" export PATH=$PATH:\"$HOME/.cargo/env\" # go export GO111MODULE=on export GOPROXY=https://goproxy.cn ","date":"2023-12-14","objectID":"/%E5%90%84%E7%A7%8D-shell-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:2:0","tags":["其他"],"title":"各种 Shell 的配置文件","uri":"/%E5%90%84%E7%A7%8D-shell-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["其他"],"content":"参考 在 Windows 终端中使用别名 alias 的方法 在 Ubuntu 安装配置 Fcitx 5 中文输入法 ","date":"2023-12-14","objectID":"/%E5%90%84%E7%A7%8D-shell-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:3:0","tags":["其他"],"title":"各种 Shell 的配置文件","uri":"/%E5%90%84%E7%A7%8D-shell-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["C"],"content":"1. 复杂度 ","date":"2023-12-13","objectID":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/:1:0","tags":["C","C++"],"title":"C/C++ 代码质量","uri":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"categories":["C"],"content":"1.1 定义 圈复杂度 (Cyclomatic complexity，CC) 是一种衡量代码复杂度的标准。圈复杂度可以用来衡量一个模块判定结构的复杂程度，其数量上表现为独立路径的条数，也可理解为覆盖所有的可能情况最少使用的测试用例个数。可作为代码重构的指导指标，也可以据此确定测试顺序。 某些大厂（例如阿里）的新代码提交后，平台会计算每个方法的圈复杂度，提醒对复杂方法进行重构。 ","date":"2023-12-13","objectID":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/:1:1","tags":["C","C++"],"title":"C/C++ 代码质量","uri":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"categories":["C"],"content":"1.2 计算方式 程序语句可以转化为如下的控制流图。 然后可以根据下面的公式计算圈复杂度，e 表示控制流图中边的数量，n 表示控制流图中节点的数量。 $$ V = e - n + 2 $$ 实际开发过程中一般借助工具直接查看结果。 ","date":"2023-12-13","objectID":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/:1:2","tags":["C","C++"],"title":"C/C++ 代码质量","uri":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"categories":["C"],"content":"1.3 工具 对于 C 代码，检查工具推荐使用 lizard。用 pip 安装后命令行直接 lizard \u003cfile\u003e 即可。 圈复杂度 代码状况 可测性 维护成本 1~10 清晰、结构化 高 低 10~20 复杂 中 中 20-30 非常复杂 低 高 \u003e30 不可读 不可测 非常高 输出结果解释： ================================================ NLOC CCN token PARAM length location ------------------------------------------------ 9 3 79 1 9 print_logpage_life@31-39@./poweroff.cpp 5 1 34 3 5 RecordData_Sys::RecordData_Sys@60-64@./poweroff.cpp 3 1 14 0 3 RecordData_Sys::~RecordData_Sys@66-68@./poweroff.cpp 11 4 79 0 11 RecordData_Sys::print_idealcontainer@70-80@./poweroff.cpp 7 2 55 1 7 RecordData_Sys::push_elem_idealcontainer@82-88@./poweroff.cpp 19 1 166 0 23 main@90-112@./poweroff.cpp 1 file analyzed. ============================================================== NLOC Avg.NLOC AvgCCN Avg.token function_cnt file -------------------------------------------------------------- 80 9.0 2.0 71.2 6 ./poweroff.cpp =============================================================================================================== No thresholds exceeded (cyclomatic_complexity \u003e 15 or length \u003e 1000 or nloc \u003e 1000000 or parameter_count \u003e 100) ========================================================================================== Total nloc Avg.NLOC AvgCCN Avg.token Fun Cnt Warning cnt Fun Rt nloc Rt ------------------------------------------------------------------------------------------ 80 9.0 2.0 71.2 6 0 0.00 0.00 对文件中每个函数分别计算下面各项，location 反映每个方法的位置。 NLOC CCN token PARAM length 排除注释和空行的总行数 圈复杂度 符号数 参数数量 函数实际行数 ","date":"2023-12-13","objectID":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/:1:3","tags":["C","C++"],"title":"C/C++ 代码质量","uri":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"categories":["C"],"content":"1.4 降低复杂度方法 模块化和函数分解：将复杂的函数或模块分解为更小的、功能更单一的子函数或模块。 减少嵌套层级：避免过多的嵌套结构，比如嵌套的 if 语句、循环和 switch 语句。 简化条件表达式：可以将复杂的条件表达式提取为单独的布尔变量或函数，使得条件逻辑更清晰。 ","date":"2023-12-13","objectID":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/:1:4","tags":["C","C++"],"title":"C/C++ 代码质量","uri":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"categories":["C"],"content":"2. 静态检查 代码静态检查是通过分析源代码本身，而不是通过执行代码来检测潜在的错误、bug 和不良风格。对于 C 项目，主要检查： 内存问题：内存泄漏、悬空指针、数组越界等 代码风格问题：缩进、括号、命名等 性能问题：不必要的循环等 代码逻辑问题：条件判断、循环控制等 C 语言的静态检查工具如下图： 以 cppcheck 为例，对于下面代码： // test.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e void foo() { int* ptr = malloc(10 * sizeof(int)); // 申请内存但未释放 if (ptr == NULL) { return; } ptr[10] = 0; // 数组越界 free(ptr); ptr = NULL; } int main() { char* str = malloc(10); strcpy(str, \"This is a long string\"); // 缓冲区溢出 printf(\"%s\\n\", str); foo(); char* ptr = malloc(10 * sizeof(int)); free(ptr); free(ptr); // 重复释放内存 return 0; } 使用命令 cppcheck test.c 直接在终端输出结果，使用 cppcheck test.c 2\u003e output.txt 输出到文本文件，结果如下： test.c:9:8: error: Array 'ptr[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds] ptr[10] = 0; // 数组越界 ^ test.c:15:12: error: Buffer is accessed out of bounds: str [bufferAccessOutOfBounds] strcpy(str, \"This is a long string\"); // 缓冲区溢出 ^ test.c:14:15: note: Assign str, buffer with size 10 char* str = malloc(10); ^ test.c:15:12: note: Buffer overrun strcpy(str, \"This is a long string\"); // 缓冲区溢出 ^ test.c:20:5: error: Memory pointed to by 'ptr' is freed twice. [doubleFree] free(ptr); // 重复释放内存 ^ test.c:19:5: note: Memory pointed to by 'ptr' is freed twice. free(ptr); ^ test.c:20:5: note: Memory pointed to by 'ptr' is freed twice. free(ptr); // 重复释放内存 ^ test.c:21:5: error: Memory leak: str [memleak] return 0; ^ ","date":"2023-12-13","objectID":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/:2:0","tags":["C","C++"],"title":"C/C++ 代码质量","uri":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"categories":["C"],"content":"3. 编程规范 对于 C/C++ 项目，影响力较大的是 Google C++ Style Guide。 下面是一些较典型的规则： 只有当函数只有 10 行甚至更少时才将其定义为内联函数。 使用标准的头文件包含顺序可增强可读性，避免隐藏依赖。避免使用 UNIX 特殊的快捷目录（比如 ./xxx.h 和 ../xxx.h）。 本文件相关头文件 C 库 C++ 库 其他库 .h 本项目所用 .h 不允许使用变长数组和 alloca() 尽可能用 sizeof(varname) 代替 sizeof(type) MISRA C/C++，是由英国汽车产业软件可靠性协会（Motor Industry Software Reliability Association）提出的 C/C++ 语言开发标准，在嵌入式开发领域有较高认可度。 tip cppcheck + python 可以实现对于 misra 规则的检查，并集成到 VScode 中。 ","date":"2023-12-13","objectID":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/:3:0","tags":["C","C++"],"title":"C/C++ 代码质量","uri":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"categories":["C"],"content":"参考 详解圈复杂度 OpenHarmony C 语言编程规范 Google C++ 风格指南 各大厂 C/C++ 编程规范 C++ 代码审查工具 Cppcheck 和 TscanCode ","date":"2023-12-13","objectID":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/:4:0","tags":["C","C++"],"title":"C/C++ 代码质量","uri":"/c_cpp-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"categories":["git"],"content":"Git flow Git 版本管理同样需要操作规范。荷兰程序员 Vincent 在 2010 年提出的方案被称为 git flow，如下图所示： 但大部分观点认为，以上流程只适用于作者所说的需要多版本并存的情况，即开发团队要同时维护多个有客户使用的版本。对于小型团队则比较复杂。与此类似的还有 Trunk-Based、Aone Flow 和最简单的 github flow 等。 ","date":"2023-12-06","objectID":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/:1:0","tags":["git"],"title":"Git 工作流","uri":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"categories":["git"],"content":"通用工作流 这里考虑最简单的情况，熟悉以下流程，其他类型的 git flow 基本都能理解。假设要修改的仓库分支是 master： clone 要完成的远程分支到本地，新建并切换到分支 git switch -c feature-branch。 本地编辑后使用 git diff 查看修改，并使用 git add \u003cchanged_file\u003e 提交修改到本地暂存区 (stage)。不建议直接用 git add . 的方式，因为一次性添加所有修改会造成不同文件的修改带有混乱的 comment。 使用 git commit -m \"comment\" 提交修改到本地，此时本地新增一个提交记录。 使用 git push origin feature-branch 提交到远程仓库。 假设此时 master 仓库有更新，这时需要把远程的修改同步到本地验证。 先 switch 到本地 master 分支 运行 git pull origin master 同步远程 master 分支的更新 切回本地 feature-branch，运行 git rebase master，如果有冲突需要手动解决。 提交合并 master 修改后的代码到 remote，使用 git push -f origin feature-branch 现在将 feature-branch 的代码同步到 master 中，进行 pull request。 负责同步 feature-branch 代码的管理者在 master 分支上进行 squash and merge 将多个连续提交合并为一个 删除远程的 feature-branch 分支 确定无误后，删除本地 feature-branch 分支 git branch -D feature-branch。 最后切到 master 分支同步 git pull origin master。 ","date":"2023-12-06","objectID":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/:2:0","tags":["git"],"title":"Git 工作流","uri":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"categories":["git"],"content":"各阶段命令常用汇总 ","date":"2023-12-06","objectID":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/:3:0","tags":["git"],"title":"Git 工作流","uri":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"categories":["git"],"content":"撤销操作 ","date":"2023-12-06","objectID":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/:4:0","tags":["git"],"title":"Git 工作流","uri":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"categories":["git"],"content":"merge / rebase Merge 操作会将两个分支的修改合并为一个新的提交，这个提交有两个父节点，分别来自于要合并的两个分支。适合用于合并公共分支、团队协作，以及当你希望保留每个分支的完整历史记录时。 Rebase 操作会将当前分支的提交“挪动”到另一个分支的最新提交之后，形成一条直线的提交历史。它会改写提交的历史记录。适合用于保持干净的提交历史、清理提交记录、以及消除分支之间的分叉，使得整个提交历史更加线性清晰。 ","date":"2023-12-06","objectID":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/:5:0","tags":["git"],"title":"Git 工作流","uri":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"categories":["git"],"content":"git 配置文件 git 的配置文件 Linux 下在 ~/.gitconfig，Windows 下一般在 C:\\Users\\username\\.gitconfig，可使用 git config --list 查看。 全局用户名和邮箱： git config --global user.name \"Your Name\" git config --global user.email \"youremail@yourdomain.com\" 可以为每个项目设置单独的 git 用户名和邮箱： git config user.name \"Your Name\" git config user.email \"youremail@yourdomain.com\" 记录账号密码： git config --global credential.helper store ","date":"2023-12-06","objectID":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/:6:0","tags":["git"],"title":"Git 工作流","uri":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"categories":["git"],"content":"github github 需要通过访问令牌验证用户，在个人设置的 settings --\u003e Developer Settings --\u003e Personal access tokens 中。生成令牌后用其代替密码输入，或者 clone 仓库后修改仓库的远端地址： git remote set-url origin https://${token_seq}@github.com/kali20177/hugo-blog-src.git ","date":"2023-12-06","objectID":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/:7:0","tags":["git"],"title":"Git 工作流","uri":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"categories":["git"],"content":"参考 如何撤销 Git 操作？ Git Flow Gitlab 基本原理 A successful Git branching model 十分钟学会正确的 github 工作流，和开源作者们使用同一套流程 git rebase VS git merge？更优雅的 git 合并方式值得拥有 ","date":"2023-12-06","objectID":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/:8:0","tags":["git"],"title":"Git 工作流","uri":"/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"categories":["C"],"content":"1. 指示器语法 designed initialiazer 数组初始化时的指示器语法： int a[10] = {0, 0, 29, 0, 0, 0, 0, 48, 0, 0}; // 等价于 int a[10] = {[2] = 29, [7] = 48}; 还可以： int a[10] = { [1] = 1, [8 ... 9] = 10 }; 结构体初始化： typedef struct { int number; char name[100]; int on_hand; } Part; struct point { int x; int y; }; // 初始化 Part part1 = {.on_hand = 10; .name = \"Disk Drive\", .number = 528}; struct point p1 = { .y = 2, .x = 1 }; // gcc old-style 可以使用不加 . 并结合 : 的初始化方式，在 clang 下会产生警告 struct point p2 = { y : 2, x : 1 }; 运行 ","date":"2023-12-05","objectID":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/:1:0","tags":["C"],"title":"C99 语法","uri":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/"},{"categories":["C"],"content":"2. 复合字面量 compound literals 就地构造一个指定类型的无名对象，在只需要定义一次数组、结构体或联合体变量时使用。 int b[] = {3, 0, 3, 4, 1}; total = sum_array(b, 5); // 等价于 total = sum_array((int []){3, 0, 3, 4, 1}); typedef struct { int number; char name[100]; int on_hand; } Part; // 作为参数传入 void print_part(struct part p) { printf(\"Part number : %d\\n\", p.number); printf(\"Part name : %s\\n\", p.name); printf(\"On hand : %d\\n\", p.on_hand); } // 传统方式 Part part1 = {528, \"Disk drive\", 10}; // 复合字面量 print_part((struct part){528, \"Disk drive\", 10})； // 复合字面量 + 指示器 print_part((struct part){.on_hand = 10; .name = \"Disk Drive\", .number = 528}); C++ 临时对象 这个特性看起来有点像 C++ 的临时匿名对象，但是复合字面量是左值。 对于 C++ 临时对象，一般的处理方法是“小数据”(尺寸在两三个指针以内) 值传递，大数据传引用。 —— 《C++ 之旅》 下面是 C++ 传递临时对象的方式： // 值传递 void myFunction1(std::vector\u003cint\u003e vec) // 常量左值引用传递 void myFunction2(const std::vector\u003cint\u003e \u0026vec) // 右值引用传递 void myFunction3(std::vector\u003cint\u003e \u0026\u0026vec) ... // 调用 myFunctionx({10, 20，30}); 一般来说，error：cannot bind non-const lvalue reference of type '...' to an rvalue of type '...' 是引用未加 const 导致的。 常量左值引用和右值引用都可以用来绑定到临时对象（右值），右值引用主要用于实现移动语义和完美转发，可以避免不必要的对象复制。如果函数需要修改参数，或者要接受可能会变的临时对象，应该使用 T\u0026\u0026。 ","date":"2023-12-05","objectID":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/:2:0","tags":["C"],"title":"C99 语法","uri":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/"},{"categories":["C"],"content":"3. inline ","date":"2023-12-05","objectID":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/:3:0","tags":["C"],"title":"C99 语法","uri":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/"},{"categories":["C"],"content":"4. flexible array member 柔性数组：在结构体中的最后一个元素允许是未知大小的数组。 柔性数组在 C 语言中有一些实际的应用场景，特别是在需要动态内存管理的情况下。 动态字符串结构体：包含一个固定大小的缓冲区和一个柔性数组用于存储字符串数据。这种结构体可以方便地进行字符串的动态管理，比如在解析文本数据时，可以动态地分配和释放字符串内存。 Redis 中使用的字符串类型 sds，最后的 buf 使用了柔性数组。C 字符串只支持 ASCII 字符，并且中间不能被 ‘\\0’ 截断。sds 类型可用于实现二进制安全的字符串。 struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; 动态数组结构体：定义动态数组结构体，其中包含一个固定大小的部分和一个柔性数组用于存储数组元素。这种结构体可以用于实现动态大小的数组，比如在需要动态管理数组大小的情况下。 struct DynamicArray { size_t size; int data[]; // 柔性数组用于存储数组元素 }; 动态数据结构：用于定义动态数据结构，比如树、图等数据结构中的节点结构体，其中柔性数组可以用于存储节点的子节点或邻接节点等动态数量的数据。 ","date":"2023-12-05","objectID":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/:4:0","tags":["C"],"title":"C99 语法","uri":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/"},{"categories":["C"],"content":"5. Pragma 运算符 #pragma once 是受到绝大多数现代编译器支持的非标准语用。但是这种方式具有局限性： Unlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with #pragma once files are excluded based on their filesystem-level identity, this can’t protect against including a header twice if it exists in more than one location in a project. 标准做法是： #ifndef LIBRARY_FILENAME_H #define LIBRARY_FILENAME_H // 头文件的内容 #endif /* LIBRARY_FILENAME_H */ 不仅可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件（或者代码片段）不会被不小心同时包含。Google C++ Style Guide 中也是采用标准做法。 不要在使用包含防护时以 __ 开头，虽然互联网上大量代码都这样做，具体参考What does double underscore ( __const) mean in C? #pragma pack 控制后继定义的结构体和联合体的最大对齐。 ","date":"2023-12-05","objectID":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/:5:0","tags":["C"],"title":"C99 语法","uri":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/"},{"categories":["C"],"content":"6. 变长数组（VLA） It generates much more code, and much slower code (and more fragile code), than just using a fixed key size would have done ~ Linus Torvalds 变长数组缩写为 VLA(variable-length array)，它是一种在运行时才确定长度的数组，通常在栈上分配内存空间。C11 中这个特性变成了可选项。 int n; int array[n]; 限制： n 和 array 必须位于同一个文件作用域 不可以用于 typedef 不可使用在结构体中 不可以申明为 static 变量 不可以申明为 extern 变量或 extern 变量的指针 限制 misra 规则和 Google C++ Style Guide 都禁用 VLA。实际使用中确实会出现很诡异的 bug。 ","date":"2023-12-05","objectID":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/:6:0","tags":["C"],"title":"C99 语法","uri":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/"},{"categories":["C"],"content":"7. 堆分配 建议使用 calloc 代替 malloc + memset. ","date":"2023-12-05","objectID":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/:7:0","tags":["C"],"title":"C99 语法","uri":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/"},{"categories":["C"],"content":"8. sizeof 语法： sizeof( 类型 ) (1) sizeof 表达式 (2) 除非用于 VLA，sizeof 是不求值表达式且 sizeof 运算符能在整数常量表达式中使用。 若表达式的类型为 VLA，则求值表达式，在运行时计算其所求值的数组大小。 ","date":"2023-12-05","objectID":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/:8:0","tags":["C"],"title":"C99 语法","uri":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/"},{"categories":["C"],"content":"参考 compound literals C99 标准的新特性 浅谈 C++ 中的临时对象 References, simply 深入浅出 C 语言中的柔性数组 C 语言柔性数组 Redis 使用及源码剖析 - 2.Redis 简单动态字符串 (SDS)-2021-1-16 现代化 C 使用体验 C 语言的 2016 实现定义行为的控制 C 语言中 #pragma once 的作用是什么？ 技术摘要 | 现代 C99, C11 标准下的 C 语言编程 VLA removal C 语言中变长数组的陷阱 ","date":"2023-12-05","objectID":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/:9:0","tags":["C"],"title":"C99 语法","uri":"/draft/cpp/c99-%E8%AF%AD%E6%B3%95/"},{"categories":["C"],"content":"1. 简单案例 下面是用 setjmp 和 longjmp 实现的简单捕获除 0 异常的一段 C 代码： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ctime.h\u003e #include \u003csetjmp.h\u003e jmp_buf exception_env; void handle_divide_by_zero(int count) { printf(\"Divide by zero exception at iteration %d\\n\", count); } int divide(int a, int b, int count) { if (b == 0) { longjmp(exception_env, 1); } return a / b; } int main() { int result, count = 1; srand((unsigned int)time(NULL)); while (1) { int a = rand() % 100; // 随机 a int b = rand() % 10; // 随机 b if (setjmp(exception_env) == 0) { result = divide(a, b, count); printf(\"Iteration %d: Result of %d / %d = %d\\n\", count, a, b, result); } else { handle_divide_by_zero(count); } count++; } return 0; } 直接从字面上分析，当每次运行除法函数时会判断是否除 0，如果是则执行 longjmp，longjmp 含义是“长跳转”，或者叫非本地跳转，第二个参数是发生跳转时携带的返回值。main 函数中如果返回值是 0 表示正常，否则执行异常 handle。 setjmp 函数的返回值有两种情况：一种是当 setjmp 第一次被调用时，它返回 0；另一种是当 longjmp 跳转回 setjmp 时，它返回 longjmp 的第二个参数值。 Return value ​0​ if the macro was called by the original code and the execution context was saved to env. Non-zero value if a non-local jump was just performed. The return value is the same as passed to longjmp. ","date":"2023-12-05","objectID":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/:1:0","tags":["C"],"title":"解毒 Setjmp \u0026 Longjmp","uri":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/"},{"categories":["C"],"content":"修改 1 以上这个例子虽然能正常工作，但是setjmp(exception_env) 出现在条件表达式时无法拿到返回值。如果要正常获取 longjmp 携带的 1，则需要改写成下面的形式： while (1) { int a = rand() % 100; // 随机 a int b = rand() % 10; // 随机 b int res = setjmp(exception_env); if (res == 0) { result = divide(a, b, count); printf(\"Iteration %d: Result of %d / %d = %d\\n\", count, a, b, result); } else { handle_divide_by_zero(count); } count++; } 修改后的形式更适合根据 longjmp 返回值分类讨论。但是，这样的用法不符合标准。 ","date":"2023-12-05","objectID":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/:1:1","tags":["C"],"title":"解毒 Setjmp \u0026 Longjmp","uri":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/"},{"categories":["C"],"content":"修改 2 虽然笔者在 Linux 和 Windows 环境下，setjmp 返回值直接赋值目前未使用出异常问题，网络上也有不少类似的例子，但在《深入理解计算机系统》第三版和《Linux/UNIX 系统编程手册》中提到，setjmp 的返回值直接赋给变量是非标准行为。 rc = setjmp(env); /* Wrong! */ SUSv3 和 C99 规定，对 setjmp() 的调用只能在如下语境中使用。 构成选择或迭代语句中（if、switch、while、do-while、for）的整个控制表达式。 switch(setjmp(env)) 作为一元操作符!（not）的操作对象，其最终表达式构成了选择或迭代语句的整个控制表达式。 while(!setjmp(env)) 作为比较操作（==、!=、\u003c等）的一部分，另一操作对象必须是一个整数常量表达式，且其最终表达式构成选择或迭代语句的整个控制表达式。 if(setjmp(env) \u003e 10) 作为独立的函数调用，且没有嵌入到更大的表达式之中。 setjmp(env); 其他行为属于未定义行为，并且 setjmp 的实际行为和优化选项也有关。在实际使用中，如果我们需要通过 longjmp 的返回值选择执行不同的异常处理过程，建议选择全局变量或者 switch-case 语句实现。 #include ... jmp_buf exception_env; int exception_type = 0; // 全局变量，用于记录异常类型 int divide(int a, int b, int count) { if (b == 0) { exception_type = 1; // 设置异常类型为 1 longjmp(exception_env, 1); } if (b == 1) { exception_type = 2; // 设置异常类型为 2 longjmp(exception_env, 2); } return a / b; } void handle_divide_by_zero(int count) { printf(\"Divide by zero exception at iteration %d\\n\", count); } void handle_divide_by_one(int count) { printf(\"Divide by one exception at iteration %d\\n\", count); } int main(int argc, char *argv[]) { int result, count = 1; srand((unsigned int)time(NULL)); // 初始化随机数种子 for (int i = 0; i \u003c 100; i++) { int a = rand() % 100; // 产生随机数 a int b = rand() % 10; // 产生随机数 b if (setjmp(exception_env) == 0) { // 正常执行 result = divide(a, b, count); printf(\"Iteration %d: Result of %d / %d = %d\\n\", count, a, b, result); } else { // 异常处理 if (exception_type == 1) { handle_divide_by_zero(count); } else if (exception_type == 2) { handle_divide_by_one(count); } // 重置异常类型 exception_type = 0; } count++; } exit(0); } 或者： int main(int argc, char *argv[]) { ... for (int i = 0; i \u003c 100; i++) { int a = rand() % 100; // 产生随机数 a int b = rand() % 10; // 产生随机数 b switch (setjmp(exception_env)) { case 0: // 正常执行 result = divide(a, b, count); printf(\"Iteration %d: Result of %d / %d = %d\\n\", count, a, b, result); break; case 1: // 处理除以 0 的异常 handle_divide_by_zero(count); break; case 2: // 处理除以 1 的异常 handle_divide_by_one(count); break; default: // 处理其他异常 break; } count++; } ... } ","date":"2023-12-05","objectID":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/:1:2","tags":["C"],"title":"解毒 Setjmp \u0026 Longjmp","uri":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/"},{"categories":["C"],"content":"2. 用途 ","date":"2023-12-05","objectID":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/:2:0","tags":["C"],"title":"解毒 Setjmp \u0026 Longjmp","uri":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/"},{"categories":["C"],"content":"2.1 异常机制 ","date":"2023-12-05","objectID":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/:2:1","tags":["C"],"title":"解毒 Setjmp \u0026 Longjmp","uri":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/"},{"categories":["C"],"content":"2.2 C 协程 ","date":"2023-12-05","objectID":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/:2:2","tags":["C"],"title":"解毒 Setjmp \u0026 Longjmp","uri":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/"},{"categories":["C"],"content":"2.3 测试 大多数 C 语言的测试框架都借助了 setjmp 和 longjmp 实现断言失败后跳出当前测试。 ","date":"2023-12-05","objectID":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/:2:3","tags":["C"],"title":"解毒 Setjmp \u0026 Longjmp","uri":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/"},{"categories":["C"],"content":"3. 局限性 这类功能使用需要非常小心，Misra Rule 21.4 直接禁用此功能。 ","date":"2023-12-05","objectID":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/:3:0","tags":["C"],"title":"解毒 Setjmp \u0026 Longjmp","uri":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/"},{"categories":["C"],"content":"4. C++ C++ 中也支持使用 setjmp 和 longjmp，在头文件 \u003ccsetjmp\u003e 中定义。保存环境时需要使用 std::jmp_buf，使用 std::longjmp 跳转。支持和 C 语言互相跳转。 ","date":"2023-12-05","objectID":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/:4:0","tags":["C"],"title":"解毒 Setjmp \u0026 Longjmp","uri":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/"},{"categories":["C"],"content":"参考 setjmp std::longjmp Linux/UNIX 系统编程手册 C 语言中 setjmp 和 longjmp ","date":"2023-12-05","objectID":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/:5:0","tags":["C"],"title":"解毒 Setjmp \u0026 Longjmp","uri":"/%E8%A7%A3%E6%AF%92-setjmp-longjmp/"},{"categories":["C"],"content":"Core dump Linux 下默认关闭该功能，开启命令： ulimit -c unlimited 使用 GDB 进行调试时，可以通过两种方式来进行调试：一种是直接调试可执行文件，另一种是调试 core 文件。以下是二者的区别： 调试可执行文件：在 debug 模式下编译的可执行文件中包含了调试信息，包括了源代码的行号、变量名等信息。通过调试可执行文件，你可以在 GDB 中查看源代码、设置断点、单步执行等操作。这种方式适用于在程序运行过程中进行实时的调试和跟踪。 调试 core 文件：当程序发生崩溃并生成了 core dump 文件时，你可以使用 GDB 加载这个 core 文件进行调试。core 文件包含了程序崩溃时的内存快照，通过加载 core 文件，你可以在 GDB 中查看程序崩溃时的内存状态、变量值、函数调用栈等信息。这种方式适用于分析程序崩溃的原因。 ","date":"2023-12-05","objectID":"/draft/cpp/gdb-%E4%BD%BF%E7%94%A8/:1:0","tags":["C"],"title":"Gdb 使用","uri":"/draft/cpp/gdb-%E4%BD%BF%E7%94%A8/"},{"categories":["C"],"content":"发生原因 访问越界：字符串结束符、空指针、野指针、下标越界 多线程 堆栈溢出：太大的局部变量，无限嵌套、递归或调用函数 Signal Action Comment SIGQUIT Core Quit from keyboard SIGILL Core Illegal Instruction SIGABRT Core Abort signal from abort SIGSEGV Core Invalid memory reference SIGTRAP Core Trace/breakpoint trap ","date":"2023-12-05","objectID":"/draft/cpp/gdb-%E4%BD%BF%E7%94%A8/:1:1","tags":["C"],"title":"Gdb 使用","uri":"/draft/cpp/gdb-%E4%BD%BF%E7%94%A8/"},{"categories":["C"],"content":"技巧 打印时显示数组下标： set print array-indexes on 打印结构体数组成员指针指向的数组，例如： typedef struct { uint32_t offset; uint32_t len; void *buf; } Wp; Wp wp[20]; ... wp[0].buf = (void *)array; 16 进制打印 wp[0].buf 指向的 array p /x *(uint8_t *)(wp[0].buf)@len ","date":"2023-12-05","objectID":"/draft/cpp/gdb-%E4%BD%BF%E7%94%A8/:2:0","tags":["C"],"title":"Gdb 使用","uri":"/draft/cpp/gdb-%E4%BD%BF%E7%94%A8/"},{"categories":["C"],"content":"VSCode 打印 STL gdb 调试 C++ 程序时，默认不能直接显示 STL 容器的值。微软文档 的配置文件 launch.json 中： { \"configurations\": [ { \"name\": \"(gdb) 启动\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/build/demo\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}/build/\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"gdb\", \"setupCommands\": [ { \"description\": \"为 gdb 启用整齐打印\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true }, { \"description\": \"将反汇编风格设置为 Intel\", \"text\": \"-gdb-set disassembly-flavor intel\", \"ignoreFailures\": true } ] } ], \"version\": \"2.0.0\" } \"text\": \"-enable-pretty-printing\" 能够打开 STL 的查看。注意使用时修改参数： program, cwd，必要时填写编译器路径。 windows 上使用 msys2 有效，使用 w64devkit 无效。 ","date":"2023-12-05","objectID":"/draft/cpp/gdb-%E4%BD%BF%E7%94%A8/:3:0","tags":["C"],"title":"Gdb 使用","uri":"/draft/cpp/gdb-%E4%BD%BF%E7%94%A8/"},{"categories":["C"],"content":"反向调试 要求 gdb 版本大于 7.0 并且支持反向调试的平台。在 windows 下使用 w64devkit 的 gcc 会出现以下提示： Process record: the current architecture doesn't support record function. 在 linux 上此功能正常。 ","date":"2023-12-05","objectID":"/draft/cpp/gdb-%E4%BD%BF%E7%94%A8/:4:0","tags":["C"],"title":"Gdb 使用","uri":"/draft/cpp/gdb-%E4%BD%BF%E7%94%A8/"},{"categories":["C"],"content":"参考 linxu core dump gdb print 设置 一文读懂 | coredump 文件是如何生成的 GDB 反向调试（Reverse Debugging） GDB 调试工具高级用法 ","date":"2023-12-05","objectID":"/draft/cpp/gdb-%E4%BD%BF%E7%94%A8/:5:0","tags":["C"],"title":"Gdb 使用","uri":"/draft/cpp/gdb-%E4%BD%BF%E7%94%A8/"},{"categories":["C++"],"content":"在使用 CMake 构建项目的情况下，默认 .c 文件使用 gcc 编译，.cpp 文件使用 g++ 编译。 可以通过导出编译选项 set(CMAKE_EXPORT_COMPILE_COMMANDS ON) 验证。 C++ 不完全兼容 C99 以后的特有语法，比如指示器语法的乱序初始化、复合字面量等。结构体的指示器语法只能在聚合类使用，且不能乱序，复合字面量在 C 中会被处理成左值。 C/C++ 混合编程，在编码阶段大致应该遵循： C 语言和 C++ 的模块单独编译成库 接口部分（.h/.hpp 文件）不能出现特有语法 尽量不要在 C 代码中使用 C++ 关键字 根据 More Effective C++ 的叙述，C/C++ 混合编程至少要考虑：name mangling、静态对象初始化、动态内存分配和数据结构兼容性。 name mangling 通过 extern “C” 解决 尽可能在 C++ 文件中写 main 函数，C 的 main 函数（如果存在）重命名为 realmain 让 C++ 的 main 调用 C++ 部分使用 new/delete、C 使用 malloc/free 对于只有非虚成员函数的 struct，其布局和 C 的 struct 相同，可以安全互相传递。 ","date":"2023-11-02","objectID":"/c-%E5%92%8C-c-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/:0:0","tags":["C++","C"],"title":"C++ 和 C 模块的相互调用","uri":"/c-%E5%92%8C-c-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/"},{"categories":["C++"],"content":"1. C++ 调用 C C++ 调 C 要相对容易。以下面代码为例： // array_d.c #include \u003cstdio.h\u003e #include \"array_d.h\" void printArray(int arr[], int size) { for (int i = 0; i \u003c size; i++) { printf(\"%d \", arr[i]); } printf(\"\\n\"); } struct MyStruct ss = { .y = 1, .x = 2, }; void printMyStruct(struct MyStruct* s) { printf(\"%d, %d\\n\", s-\u003ex, s-\u003ey); } // array_d.h # pragma once struct MyStruct { int x; int y; }; void printArray(int arr[], int size); void printMyStruct(struct MyStruct* s); 可以看出，array_d.c 涉及到 C99 语法，而接口部分和 C++ 兼容，C++ 部分调用时使用 extern \"C\" 引入头文件： #include \u003ciostream\u003e #include \u003citerator\u003e #include \u003cvector\u003e #include \u003cmemory\u003e // 在 C 语言模块中定义的处理数组的函数 extern \"C\" { #include \"array_d.h\" } template \u003ctypename T\u003e std::unique_ptr\u003cT[]\u003e vectorToArray(const std::vector\u003cT\u003e\u0026 vec) { std::unique_ptr\u003cT[]\u003e arr(new T[vec.size()]); for (std::size_t i = 0; i \u003c vec.size(); ++i) { arr[i] = vec[i]; } return arr; } int main() { std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; // 调用 vectorToArray 函数，将产生的数组作为参数传递给 C 风格的函数 auto arr = vectorToArray(vec); printArray(arr.get(), vec.size()); const int s = 6; int num[s] = {1, 2, 3, 4, 5, 6}; printArray(num, s); } C++ 中允许使用常量表达式定义数组大小，可以看到这种方式的数组能正常调用 C 库函数。 由于 g++ 编译器编译过程中默认会在 .cpp 文件定义一个宏 #define __cplusplus，因此也可以这样： # pragma once #ifdef __cplusplus extern \"C\" { #endif //__cplusplus struct MyStruct { int x; int y; }; void printArray(int arr[], int size); void printMyStruct(struct MyStruct* s); #ifdef __cplusplus } #endif //__cplusplus 这种方式能避免在 cpp 文件调用 array_d.h 时显式使用 extern \"C\"。 另外，C++ 中可以继承来自 C 模块的结构体，例如对于： // usart.h # pragma once #include \u003cstdint.h\u003e typedef struct { uint32_t baud_rate; uint16_t stop_bits; } USART_InitDef; 可以直接使用 public 继承，但是注意派生类的构造函数定义需要调用\"基类\"的默认构造函数。建议使用 { } 调用 C 结构体的默认构造，使用 ( ) 在 clang-15 编译不通过。 struct MyUsart : public USART_InitDef { using BaudRate_t = const uint32_t; using StopBits_t = const uint16_t; public: MyUsart(BaudRate_t baud_rate, StopBits_t stop_bits) : USART_Def{baud_rate, stop_bits} { } MyUsart() = delete; MyUsart(const MyUsart\u0026) = delete; MyUsart(MyUsart\u0026\u0026) = delete; }; 在嵌入式场景应用中，可以用 C++ 继承 C 模块的结构体，使用链式调用配置设备： // device.h #pragma once typedef struct { int baudRate; int dataBits; int stopBits; } DeviceConfig; 链式调用：每个成员方法都返回对象的引用，一种实现函数式编程的方式。注意成员函数之间应该互相解耦，达到调用顺序无关的效果。 // device.cpp class Device : public DeviceConfig { public: Device\u0026 setBaudRate(int rate) { baudRate = rate; return *this; } Device\u0026 setDataBits(int bits) { dataBits = bits; return *this; } Device\u0026 setStopBits(int bits) { stopBits = bits; return *this; } void printConfiguration() { std::cout \u003c\u003c \"Baud Rate: \" \u003c\u003c baudRate \u003c\u003c std::endl; std::cout \u003c\u003c \"Data Bits: \" \u003c\u003c dataBits \u003c\u003c std::endl; std::cout \u003c\u003c \"Stop Bits: \" \u003c\u003c stopBits \u003c\u003c std::endl; } }; // init Device device; device.setBaudRate(9600).setDataBits(8).setStopBits(1).printConfiguration(); ","date":"2023-11-02","objectID":"/c-%E5%92%8C-c-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/:1:0","tags":["C++","C"],"title":"C++ 和 C 模块的相互调用","uri":"/c-%E5%92%8C-c-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/"},{"categories":["C++"],"content":"2. C 调用 C++ 对于普通函数，只需要接口兼容 C 语言语法并像上面一样使用 __cplusplus 宏包装。 对于类方法，可以给每个方法写“适配层”。例如下面的例子： // Person.h #pragma once #include \u003cstring\u003e class Person { public: Person(const std::string\u0026 name, int age); ~Person(); void sayHello(); void setAge(int age); int getAge(); private: std::string name; int age; }; // Person.cpp #include \"Person.h\" #include \u003ciostream\u003e Person::Person(const std::string\u0026 name, int age) : name(name), age(age) {} Person::~Person() {} void Person::sayHello() { std::cout \u003c\u003c \"Hello, my name is \" \u003c\u003c name \u003c\u003c \", I am \" \u003c\u003c age \u003c\u003c \" years old.\" \u003c\u003c std::endl; } void Person::setAge(int age) { this-\u003eage = age; } int Person::getAge() { return age; } 定义给 C 调用的 API： // PersonWrapper.h #pragma once #ifdef __cplusplus extern \"C\" { #endif // C 风格的接口函数声明 typedef void* PersonPtr; //------------------------------------------------------------ // 类方法 //------------------------------------------------------------ PersonPtr createPerson(const char* name, int age); void deletePerson(PersonPtr person); void personSayHello(PersonPtr person); void personSetAge(PersonPtr person, int age); int personGetAge(PersonPtr person); //------------------------------------------------------------ // 普通函数 //------------------------------------------------------------ void testfunc(int argc); #ifdef __cplusplus } #endif // PersonWrapper.cpp #include \"PersonWrapper.h\" #include \"Person.h\" PersonPtr createPerson(const char* name, int age) { return new Person(name, age); } void deletePerson(PersonPtr person) { delete static_cast\u003cPerson*\u003e(person); } void personSayHello(PersonPtr person) { static_cast\u003cPerson*\u003e(person)-\u003esayHello(); } void personSetAge(PersonPtr person, int age) { static_cast\u003cPerson*\u003e(person)-\u003esetAge(age); } int personGetAge(PersonPtr person) { return static_cast\u003cPerson*\u003e(person)-\u003egetAge(); } void testfunc(int argc){ std::cout \u003c\u003c \"testfunc : \"\u003c\u003c argc \u003c\u003c \"\\n\"; return; } 调用： #include \"Person_c_api.h\" #include \u003cstdio.h\u003e int main(int argc, char *argv[]) { PersonPtr person = createPerson(\"John\", 30); personSayHello(person); personSetAge(person, 31); printf(\"New age: %d\\n\", personGetAge(person)); deletePerson(person); testfunc(3); return 0; } 对于函数重载问题，需要写多个不同的函数分别处理。 也可以直接在 C++ 文件中显式使用 extern \"C\" 导出给 C 模块使用的接口，例如下面的例子： #include \"event.hpp\" #include \u003cstring\u003e #include \u003ciostream\u003e class Base { private: std::string str; public: Base(std::string s) : str(s) { } void PrintBase() std::cout \u003c\u003c str \u003c\u003c \"\\n\"; }; void EventLoopCpp() { std::cout \u003c\u003c \" -- C++ function here -- \" \u003c\u003c \"\\n\"; } extern \"C\" { void EventLoopC() { Base b(\" -- class here --\"); b.PrintBase(); EventLoopCpp(); } } 然后在对应的 .h/.hpp 文件中分别包含这两类接口，C 语言中直接包含 .h/.hpp 调用 EventLoopC(); 即可。 #include 只做展开，所以能够直接包含 .hpp 文件。 #ifndef EVENTLOOP_HPP_ #define EVENTLOOP_HPP_ // C++ API void EventLoopCpp(); // C API #ifdef __cplusplus extern \"C\" { #endif void EventLoopC(); #ifdef __cplusplus } #endif #endif /* EVENTLOOP_HPP_ */ ","date":"2023-11-02","objectID":"/c-%E5%92%8C-c-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/:2:0","tags":["C++","C"],"title":"C++ 和 C 模块的相互调用","uri":"/c-%E5%92%8C-c-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/"},{"categories":["C++"],"content":"参考 C/C++ 中的 extern 和 extern “C” 关键字的理解和使用 分析解决 sorry, unimplemented: non-trivial designated initializers not supported 数组乱序初始化：sorry, unimplemented: non-trivial designated initializers not supported 在 GCC 环境中开发 C 和 C++ 混合项目 如何从 C 中调用 C++ 函数 C、C++ 混合调用 C 语言编译错误：Variably modified array at file scope how-to-use-cpp-with-stm32-hal ","date":"2023-11-02","objectID":"/c-%E5%92%8C-c-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/:3:0","tags":["C++","C"],"title":"C++ 和 C 模块的相互调用","uri":"/c-%E5%92%8C-c-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/"},{"categories":["数据结构"],"content":"2023.09.17 [1768] 交替合并字符串 char * mergeAlternately(char * word1, char * word2) { int len1 = strlen(word1); int len2 = strlen(word2); char* res = malloc((strlen(word1) + strlen(word2) + 1) * sizeof(char)); memset(res, '\\0', (strlen(word1) + strlen(word2) + 1)); int i = 0, j = 0, k = 0; while (j \u003c len1 \u0026\u0026 k \u003c len2) { if (i % 2 == 0) res[i] = word1[j], j ++; else res[i] = word2[k], k ++; i++; } if (word1[j] != '\\0') { while (j \u003c len1) res[i] = word1[j], j++, i++; } if (word2[k] != '\\0') { while (k \u003c len2) res[i] = word2[k], k++, i++; } return res; } [206] 反转链表 struct ListNode* reverseList(struct ListNode* head){ struct ListNode* pre = NULL; // 前驱节点，记录链表信息，最后作为结果返回 struct ListNode* cur = head; // 新建 cur 节点，避免操作 head while (cur != NULL) { struct ListNode* tmp = cur -\u003e next; // 保存断开节点后的信息 cur -\u003e next = pre; pre = cur; cur = tmp; } return pre; } [26] 删除有序数组 int removeDuplicates(int* nums, int numsSize){ int index = 0; // 记录数组实际不重复数组长度 // j \u003c numsSize for (int i = 1; i \u003c numsSize; i++) { if (nums[i] != nums[index]) { nums[++index] = nums[i]; } } return index + 1; } [234] 回文链表 C 语言遍历链表到数组 C 语言的双指针 bool isPalindrome(struct ListNode* head){ int vals[1000001], index = 0; while (head != NULL) { vals[index++] = head -\u003e val; head = head -\u003e next; } for (int i = 0, j = index - 1; i \u003c j; ++i, --j) { if (vals[i] != vals[j]) return false; } return true; } [1832] 判断句子是否为全字母句 bool checkIfPangram(char * sentence){ int map[26] = { 0 }; int len = strlen(sentence); for (int i = 0; i \u003c len; i ++) { map[sentence[i] - 97]++; } for (int j = 0; j \u003c 26; j++) { if (map[j] == 0) return false; } return true; } [2828] 判别首字母缩略词 bool isAcronym(char ** words, int wordsSize, char * s) { char res[101] = \"\"; for (int i = 0; i \u003c wordsSize; i++) { res[i] = words[i][0]; } if (strcmp(res, s) == 0) return true; else return false; } C 语言中字符串数组 char str[3] = {\"AA\", \"B\", \"CCC\"}; C 语言字符串数组的两种表示方法 作为参数传入： bool isAcronym(char ** words, int wordsSize, char * s) 比较字符串 if (strcmp(res, s) == 0) return true; ","date":"2023-10-05","objectID":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/leetcode-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:1:0","tags":["数据结构"],"title":"Leetcode 刷题记录","uri":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/leetcode-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["CMake"],"content":"1. CMake 基本构建 以下面结构的简单项目为例，子项目 test 中需要依赖一个测试框架 Unity, 一个只有头文件和源码的 log 库和一个由多个源文件和头文件组成的哈希表库 uthash。测试框架 Unity 提供了 CMakelists.txt。  . ├──  inc │ ├──  module1 │ └──  module2 ├──  src │ ├──  module1 │ ├──  module2 │ └──  main.c └──  test ├──  module1_test ├──  module2_test └──  third_party ├──  unity ├──  uthash └──  log.c 顶层 cmakelists.txt 的基本元素如下： cmake_minimum_required(VERSION 3.20) project(hello C) # C 语言标准 set(CMAKE_C_STANDARD 99) set(CMAKE_BUILD_TYPE Debug) # 禁止在源目录编译以及修改 set(CMAKE_DISABLE_IN_SOURCE_BUILD ON) set(CMAKE_DISABLE_SOURCE_CHANGES ON) # 不同模式下全局的编译选项 SET(CMAKE_CXX_FLAGS_DEBUG \"-Wall -g\") SET(CMAKE_CXX_FLAGS_RELEASE \"-O3\") # clangd 支持，查看编译命令，生成一个 compile_commands.json set(CMAKE_EXPORT_COMPILE_COMMANDS ON) add_executable(${PROJECT_NAME} src/main.c) target_link_libraries(${PROJECT_NAME} PUBLIC m) # 链接数学库 # 开启 ctest 功能，此选项需要在顶层 CMakeLists.txt 定义 include(CTest) # 添加子项目 add_subdirectory(test) 配置 test 文件夹的子项目，需要新建一个 test/CMakeLists.txt，可以使用下面的示例： project(test_runner) # Unity add_subdirectory(third_party/Unity) # log.c .h 文件目录 include_directories(third_party/log.c/src/) # uthash 源码目录 file(GLOB UTHASH \"third_party/uthash/src/*.c\") add_executable(${PROJECT_NAME} test_runner.c ${UTHASH}) # 直接添加第三方项目的源文件 target_sources(${PROJECT_NAME} PRIVATE third_party/log.c/src/log.c third_party/log.c/src/log.h) # 设置第三方项目的条件编译选项 target_compile_definitions(${PROJECT_NAME} PRIVATE LOG_USE_COLOR) # 添加 ctest 测试 add_test(${PROJECT_NAME} ${PROJECT_NAME}) target_link_libraries(${PROJECT_NAME} unity) 对于像 Unity 一样使用 CMake 构建，且顶层有 CMakeList.txt 的库，可以直接使用 add_subdirectory 以子项目形式导入。 哈希库 uthash 只提供了一个文件夹，可以使用 file 函数使用通配符添加指定的文件保存到变量，建议使用 CONFIGURE_DEPENDS, 添加新文件时可以自动更新变量（CMake 3.12 起）。 file(GLOB UTHASH CONFIGURE_DEPENDS \"third_party/uthash/src/*.c\") 如果想直接添加额外某几个源文件参与构建，使用 target_sources 添加文件路径（CMake 3.13 起）。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:1:0","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"2. 相对路径定义 一般 CMake 工程将可执行文件产生在 build 路径，当 C/C++ 工程需要读写工程目录下的文件或者产生数据时，如果通过绝对路径寻找文件则丧失了可移植性。 这时可以在 cmake 中定义工作路径宏或者使用 configure_file 功能解决。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:2:0","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"2.1 add_definitions add_definitions(-DPROJECT_ROOT=\"${CMAKE_CURRENT_SOURCE_DIR}\") 在 C++ 程序中，执行下面的语句就能获取这个路径。 string file_path = string(PROJECT_ROOT); 在 C 程序中，需要定义辅助宏解决。 #include \u003cstdio.h\u003e #define STR_HELPER(x) #x #define STR(x) STR_HELPER(x) int main() { printf(\"Project root: %s\\n\", STR(PROJECT_ROOT)); return 0; } 在 STR_HELPER(x) 中，# 将宏参数 x 转换为一个字符串字面量。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:2:1","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"2.2 configure_file 此命令的功能是在构建时，将文件（一般是 .in 结尾）复制到另一个位置并修改 CMake 变量，一般用于在构建过程中动态生成头文件、配置文件、脚本文件。例如现在需要把 log 文件产生在工程目录的 test/log 文件夹。 set(LOG_DIR \"${CMAKE_SOURCE_DIR}/test/log\") configure_file(${CMAKE_SOURCE_DIR}/test/config.h.in ${CMAKE_SOURCE_DIR}/include/config.h @ONLY) config.h.in 的内容 #pragma once #define LOG_DIR \"@LOG_DIR@\" 构建项目时，将在 include 目录中生成文件 config.h 并带有正确路径。 当打开 CMAKE_DISABLE_SOURCE_CHANGES 时，将无法使用 configure_file 功能。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:2:2","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"3. 代码覆盖率 C/C++ 的代码覆盖率主要是利用 gcc 套件中的 gcov 组件产生，加入特殊选项编译后会产生 *.gcno 文件，运行测试后进一步产生 *.gcda 文件，二者结合源码，使用 gcov ${program.gcno} 命令生成覆盖率信息。一般需要进一步使用 lcov 或者 gcovr 产生可读性更强的报告。 lcov 是一个 perl 项目，Linux 平台开发使用较多，跨平台能力差，在 windows 上使用 gcc 编译的项目无法使用。 gcovr 是一个 Python 项目，资料较少，跨平台能力较好，能集成到 jenkins 产生代码覆盖率趋势。 OpenCppCoverage 是专门给 Windows 平台的代码覆盖率工具，运行依赖与 MSVC 编译过程中产生的 pdb 文件。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:3:0","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"3.1 Gcov 编译选项 这里参考 gcovr 的官方文档。编译时需要打开 gcc 选项 --coverage （此项等同于 -fprofile-arcs -ftest-coverage），同时要禁用优化选项。 set(CMAKE_C_FLAGS \"-g -O0 -Wall --coverage\") set(CMAKE_CXX_FLAGS \"-g -O0 -Wall --coverage\") ... add_compile_options(--coverage) add_link_options(--coverage) 由于代码覆盖率不仅要看测试代码，还要看被测代码，因此编译选项需要全局打开。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:3:1","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"3.2 VSCode Gcov View 在 VSCode 中可以借助插件 Gcov View 显示代码覆盖情况。 生成 .gcda 文件后，Ctrl + shift + p 输入 “Gcov Viewer”，选择 show 即可看到哪些行被覆盖。 使用过程中可能会发现如下执行错误： 这种情况下使用 gcov xxx.gcno 也会出现错误： 这是由于命令行调用的 gcov 版本和编译使用的 gcc 版本不一致导致的。尤其是在使用 cmake 插件没有规定编译工具链版本时容易出现此类问题。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:3:2","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"3.3 Gcovr 可以使用 pip 安装，要确保 python 安装的可执行文件添加到了环境变量中。 pip install gcovr 由于 CMake 源码和编译文件是分离的，产生报告的命令为： \u003e gcovr -r $SRC_Path $BUILD_Path 例如 CMake 编译产生的文件夹是 build，build 目录和 src 目录在同一级，执行： cd build gcovr -r ../ . 程序会递归扫描文件夹下所有 .gcno 文件。输出结果类似于： ------------------------------------------------------------------------------ GCC Code Coverage Report Directory: ../ ------------------------------------------------------------------------------ File Lines Exec Cover Missing ------------------------------------------------------------------------------ src/example/crc.c 6 6 100% src/example/example.c 2 0 0% 3,5 src/main.c 6 6 100% test/example/crc_test.c 27 27 100% test/example/main_test.c 5 5 100% 如果要产生 html 报告，并设置标题，排除一些文件夹，需要添加参数： gcovr -r ../ . --html --html-details --html-title \"report name\" -e ../test/ -o report.html 总体： 细分： 进一步可以产生 xml 格式报告集成到 Jenkins 中。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:3:3","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"4. 常用配置项 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:4:0","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"4.1 项目问题检查 Sanitizer gcc/clang 集成了 Sanitizer 内存检查工具。包括： AddressSanitizer: a memory error detector LeakSanitizer: a memory leak detector MemeorySanitizer: a detector of uninitialized reads ThreadSanitizer: a data race and deadlock detector UndefinedBehaviorSanitizer: a undefined behavior detector 开启需要在 CMakeLists.txt 中定义： set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -fsanitize=address -fno-omit-frame-pointer -fsanitize=undefined -fsanitize=leak -fsanitize=signed-integer-overflow\") set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=address -fno-omit-frame-pointer -fsanitize=undefined -fsanitize=leak -fsanitize=signed-integer-overflow\") set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -fsanitize=address -fno-omit-frame-pointer -fsanitize=undefined -fsanitize=leak -fsanitize=signed-integer-overflow\") ... # 下面一行实际环境中不一定需要开启，一般 gcc 自动支持 target_link_libraries(${PROJECT_NAME} asan) 运行后，输出结果额外带有内存泄漏位置的调用栈，顺着查找即可。以下是一些常用的参数： -fsanitize=address：启用 AddressSanitizer（ASan） -fsanitize=leak：启用 LeakSanitizer，用于检测内存泄漏。 -fsanitize=thread：启用 ThreadSanitizer，用于检测并发程序中的数据竞争和死锁。 -fsanitize=memory：启用 MemorySanitizer，用于检测对未初始化内存的访问，有助于提高内存安全性。 -fsanitize=signed-integer-overflow：用于检测整数溢出。 -fno-omit-frame-pointer：告诉编译器不要优化掉函数调用的框架指针。在进行调试或性能分析时，框架指针对于跟踪函数调用关系非常重要。 -fsanitize=undefined：启用 UndefinedBehaviorSanitizer（UBSan），它用于检测一些未定义行为。比如整数溢出、除以零等。 可以将以上选项提取到项目的 cmake/SanitizerOptions.cmake 文件中。 macro(set_sanitizer_options) set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -fsanitize=address -fno-omit-frame-pointer -fsanitize=undefined -fsanitize=leak -fsanitize=signed-integer-overflow\") set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=address -fno-omit-frame-pointer -fsanitize=undefined -fsanitize=leak -fsanitize=signed-integer-overflow\") set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -fsanitize=address -fno-omit-frame-pointer -fsanitize=undefined -fsanitize=leak -fsanitize=signed-integer-overflow\") endmacro() 在 CMakeLists.txt 中 include。 # 选项开关 option(USE_SANITIZER \"Use Sanitizer\" OFF) ... # 导入额外编译选项 if(USE_SANITIZER) include(cmake/SanitizerOptions.cmake) set_sanitizer_options() endif() ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:4:1","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"4.2 保留预处理后文件 添加编译选项： set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -save-temps=obj\") set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -save-temps=obj\") ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:4:2","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"4.3 输出 map 文件 输出 .map 文件到 build 目录，添加链接选项： set(MAP_FILE ${CMAKE_BINARY_DIR}/${PROJECT_NAME}.map) set(CMAKE_EXE_LINKER_FLAGS \"-Wl,-Map=${MAP_FILE}\") ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:4:3","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"4.4 设置输出目录 CMAKE_ARCHIVE_OUTPUT_DIRECTORY、CMAKE_LIBRARY_OUTPUT_DIRECTORY 和 CMAKE_RUNTIME_OUTPUT_DIRECTORY 变量用于指定构建过程中生成的静态库、动态库和可执行文件的输出路径。CMAKE_INSTALL_LIBDIR 和 CMAKE_INSTALL_BINDIR 是预定义的变量。 set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR}) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR}) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR}) ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:4:4","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"4.5 启用调试中宏打印 set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -g3 -O0 -Wall\") # 也有写成 set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -gdwarf-2 -g3 -O0 -Wall\") ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:4:5","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"4.6 开启 LTO LTO（Link Time Optimization）是一种编译优化技术，它在链接阶段对整个程序进行优化，而不仅仅是在单独编译单元的优化。可能会增加编译时间和内存占用。可以通过变量 CMAKE_INTERPROCEDURAL_OPTIMIZATION（CMake 3.9+ 可用）或对目标指定 INTERPROCEDURAL_OPTIMIZATION 属性来打开它。 # 设置 Release 模式下启用 LTO 编译选项 if(CMAKE_BUILD_TYPE STREQUAL \"Release\") include(CheckIPOSupported) check_ipo_supported(RESULT result) if(result) message(STATUS \"LTO is supported\") set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE) else() message(WARNING \"LTO is not supported\") endif() endif() # 为特定目标设置 LTO include(CheckIPOSupported) check_ipo_supported(RESULT result) if(result) set_target_properties(foo PROPERTIES INTERPROCEDURAL_OPTIMIZATION TRUE) endif() ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:4:6","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"4.7 地址无关代码 (Position independent code) 动态链接库必须。一般用标志 -fPIC 来设置。大部分情况下，不需要去显式声明，CMake 将会在 SHARED 以及 MODULE 类型的库中自动的包含此标志。如果需要显式的声明： # 对某个目标设置 fPIC 标志 set_target_properties(lib1 PROPERTIES POSITION_INDEPENDENT_CODE ON) ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:4:7","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"5. Arm 项目和 x86 项目构建上的区别 最典型的例子，char 的符号性并没有明确定义，取决于编译器实现。ARM 架构的 LDRSB 指令，可以将一个有符号字节加载到 32 位寄存器并进行符号扩展。但是，这个指令不是 ARM 架构最早版本的一部分。当时为了避免符号扩展的开销，arm 平台的 char 默认是无符号类型。 在 CMake 中通过设置 gcc 的编译选项来调整编译时的符号性。 set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -fsigned-char\") 除此之外构建跨平台项目需要注意： 浮点数处理：ARM 有硬浮点和软浮点两种模式，可以通过 -mfloat-abi 选项来选择。 指令集版本：ARM 有多个版本的指令集，例如 ARMv7、ARMv8 等，通过 -march 选项来指定目标架构。 内存模型：ARM 支持多种内存模型，包括小端（little-endian）和大端（big-endian）。通过 -mlittle-endian 或 -mbig-endian 选项来选择。x86 平台默认使用小端模型。 ABI（Application Binary Interface）：不同的 ARM ABI（如 AAPCS、AAPCS-VFP 等）可能影响函数调用约定、数据对齐等。通过 -mabi 选项来选择。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:5:0","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"6. VSCode 集成 Vcpkg 包管理 安装 vcpkg 并进行如下必要的设置： git clone https://github.com/microsoft/vcpkg.git ./bootstrap-vcpkg.sh cd vcpkg ./vcpkg integrate bash # or zsh ./vcpkg install fmt 在工作区的 settings.json 中添加 CMAKE_TOOLCHAIN_FILE： { \"cmake.configureSettings\": { \"CMAKE_TOOLCHAIN_FILE\": \"[vcpkg root]/scripts/buildsystems/vcpkg.cmake\" } } 也可以直接在 CMakeLists.txt 中添加： set(CMAKE_TOOLCHAIN_FILE \"[vcpkg root]/scripts/buildsystems/vcpkg.cmake\") 重新加载工作区后就能使用 vcpkg 安装的包： find_package(fmt CONFIG REQUIRED) ... target_link_libraries(${PROJECT_NAME} PRIVATE fmt::fmt-header-only) ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:6:0","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"7. CMake Presets 当项目越来越复杂，需要考虑跨系统、架构、编译器以及测试各种编译选项时，cmake 就会存在许多需要设置的选项，具体表现为每构建一次，就需要输入一堆 -D 选项，同时 CMakeLists.txt 中的内容会变冗余繁杂。 CMake 3.19 后更新的预设功能，可以通过项目顶层的 CMakePresets.json 和 CMakeUserPresets.json 文件，构成配置矩阵，简化 CMakeLists.txt 和参数输入。 以一个 hello world 项目举例，通过 option USE_SDL 控制是否生成图形界面版本，否则生成命令行版本。编译时使用包管理器安装的 gcc-11 和不在环境变量中的 gcc-13。下面是 CMakePresets.json 的内容： { \"version\": 3, \"configurePresets\": [ { \"name\": \"ci-base\", \"displayName\": \"base config\", \"generator\": \"Unix Makefiles\", \"binaryDir\": \"build\", \"cacheVariables\": { \"CMAKE_C_STANDARD\": \"99\", \"CMAKE_CXX_STANDARD\": \"20\" }, \"hidden\": true }, { \"name\": \"ci-debug\", \"inherits\": \"ci-base\", \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"Debug\", \"CMAKE_CXX_FLAGS\": \"-g\" } }, { \"name\": \"ci-release\", \"inherits\": \"ci-base\", \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"Release\", \"CMAKE_CXX_FLAGS\": \"-O3\" } } ] } CMakePresets.json 中编写通用配置，也可以用于 CI 构建。上面的内容定义了项目的通用配置，“inherits” 用于继承其他字段的定义，可以继承多个字段。通过 “hidden” 隐藏不必要的组件字段。 CMakeUserPresets.json 通常由开发人员定义特殊配置，在自己的构建环境中使用，因此不应将其置于版本控制中。 应该从名称上区分项目预设还是自定义预设。可以在项目定义预设加上 “ci-” 前缀。 CMakeUserPresets.json 的内容如下： { \"version\": 3, \"configurePresets\": [ { \"name\": \"gcc-12\", \"hidden\": true, \"cacheVariables\": { \"CMAKE_C_COMPILER\": \"gcc-12\", \"CMAKE_CXX_COMPILER\": \"g++-12\" } }, { \"name\": \"gcc-13\", \"hidden\": true, \"cacheVariables\": { \"CMAKE_C_COMPILER\": \"/opt/gcc-13.2.0/bin/gcc\", \"CMAKE_CXX_COMPILER\": \"/opt/gcc-13.2.0/bin/g++\", \"CMAKE_INSTALL_RPATH\": \"/opt/gcc-13.2.0/lib64\", \"CMAKE_BUILD_WITH_INSTALL_RPATH\" : true } }, { \"name\": \"gui app debug\", \"inherits\": [\"ci-debug\", \"gcc-13\"], \"binaryDir\": \"${sourceDir}/build/gui\", \"cacheVariables\": { \"CMAKE_CXX_FLAGS\": \"-Wall\", \"USE_SDL\":true } }, { \"name\": \"console app debug\", \"inherits\": [\"ci-debug\", \"gcc-12\"], \"binaryDir\": \"${sourceDir}/build/console\", \"cacheVariables\": { \"CMAKE_CXX_FLAGS\": \"-Wall\", \"USE_SDL\":false } } ], \"buildPresets\" :[ { \"name\": \"gui app debug\", \"configurePreset\": \"gui app debug\" }, { \"name\": \"console app debug\", \"configurePreset\": \"console app debug\" } ] } CMakeUserPresets.json 可以直接继承 CMakePresets.json 中的字段。注意此处的 “CMAKE_CXX_FLAGS” 字段并不会覆盖 CMakePresets.json 中的 “CMAKE_CXX_FLAGS” 设置，而是在原来的基础上添加。 每个 “buildPresets” 需要配合一个同名 “configurePreset” 完成构建，此时可以查看 cmake 预设： ➜ cmake --list-presets Available configure presets: \"gui app debug\" \"console app debug\" \"ci-debug\" \"ci-release\" 如果此时要构建 gui 版本，则输入： cmake --preset \"gui app debug\" cmake --build --preset \"gui app debug\" 如果使用 VSCode 插件则无需输入命令行，直接鼠标点选即可构建。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:7:0","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"8. rpath 全名 Run-time Search Path，运行时链接器搜索路径。这个值硬编码在可执行文件或者动态库的 ELF 结构的 .dynamic 节中。动态库搜索路径的顺序： rpath LD_LIBRARY_PATH RUNPATH ldconfig 内置路径 /lib、/usr/lib 使用 gcc 编译程序时，-L 指定编译时搜索动态库的位置，选项 -Wl,-rpath 指定程序运行时搜索动态库的路径。 在 CMake 中主要由下面几个变量控制： CMAKE_INSTALL_RPATH 程序安装后，搜索 dynamic library 路径 CMAKE_BUILD_WITH_INSTALL_RPATH 设为 True 时默认使用 CMAKE_INSTALL_RPATH CMAKE_BUILD_RPATH_USE_ORIGIN 使用 $origin 相对路径 在 CMake 构建完成程序会带有 rpath，但如果程序需要考虑安装问题时需要设置此项。 另一种使用场景是使用自己编译的工具链版本构建程序时，添加链接路径，假设 gcc-13 被安装在了路径 /opt/gcc-13.2.0/： cmake_minimum_required(VERSION 3.20) project(MyProject) # 检查编译器版本是否是 gcc-13 if (CMAKE_CXX_COMPILER_ID STREQUAL \"\" AND CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL \"13.2.0\") message(STATUS \"Detected GCC 13 compiler\") set(CMAKE_INSTALL_RPATH \"/opt/gcc-13.2.0/lib64\") set(CMAKE_BUILD_WITH_INSTALL_RPATH true) endif() # 添加源文件和可执行文件 add_executable(MyExecutable main.cpp) # 安装目标 install(TARGETS MyExecutable DESTINATION bin) 这样程序运行时就不会出现各种 'GLIBC_2.xx' not found 的问题。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:8:0","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"9. 编译选项控制 target_compile_options 命令用于给特定构建目标添加编译选项。可以添加三个级别的可见性：INTERFACE、PUBLIC 和 PRIVATE。定义如下： PRIVATE，编译选项会应用于给定的目标，不会传递给与目标相关的目标。 INTERFACE，给定的编译选项将只应用于指定目标，并传递给与目标相关的目标。 PUBLIC，编译选项将应用于指定目标和使用它的目标。 例如： list(APPEND flags \"-fno-exceptions\" \"-fno-rtti\") add_library(xlib STATIC xxx.cpp) target_compile_options(xlib PRIVATE ${flags}) 检查对每个源文件的编译选项，除了设置 CMAKE_EXPORT_COMPILE_COMMANDS 外，还可以通过 cmake --build . -- VERBOSE=1 选项 CMAKE_EXPORT_COMPILE_COMMANDS 仅当使用 Makefile 和 Ninja 生成器时有效。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:9:0","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"10. Clang 静态分析器 安装 clang 和 llvm 套件，安装 clang static analyzer： sudo apt install clang-tools scan-build -h 在执行 cmake 和 make 命令前加上 scan-build，将会替换 CC 和 CXX 环境变量。 scan-build cmake .. scan-build make 如果找到错误会有类似提示： scan-build: Analysis run complete. scan-build: 2 bugs found. scan-build: Run 'scan-view /tmp/scan-build-2024-04-30-151415-5388-1' to examine bug reports. 执行提示的 scan-view xxx 可以在浏览器上查看错误详情。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:10:0","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"11. CMake 行为准则 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:11:0","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"11.1 CMake 应避免的行为 不要使用具有全局作用域的函数：这包含 link_directories、 include_libraries 等相似的函数。 不要添加非必要的 PUBLIC 要求：你应该避免把一些不必要的东西强加给用户（-Wall）。相比于 PUBLIC，更应该把他们声明为 PRIVATE。 不要在 file 函数中添加 GLOB 文件：如果不重新运行 CMake，Make 或者其他的工具将不会知道你是否添加了某个文件。值得注意的是，CMake 3.12 添加了一个 CONFIGURE_DEPENDS 标志能够使你更好的完成这件事。 将库直接链接到需要构建的目标上：如果可以的话，总是显式的将库链接到目标上。 当链接库文件时，不要省略 PUBLIC 或 PRIVATE 关键字：这将会导致后续所有的链接都是默认的。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:11:1","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"11.2 CMake 应遵守的规范 把 CMake 程序视作代码：它是代码。它应该和其他的代码一样，是整洁并且可读的。 建立目标的观念：你的目标应该代表一系列的概念。为任何需要保持一致的东西指定一个（导入型）INTERFACE 目标，然后每次都链接到该目标。 导出你的接口：你的 CMake 项目应该可以直接构建或者安装。 为库书写一个 Config.cmake 文件：这是库作者为支持客户的体验而应该做的。 声明一个 ALIAS 目标以保持使用的一致性：使用 add_subdirectory 和 find_package 应该提供相同的目标和命名空间。 将常见的功能合并到有详细文档的函数或宏中：函数往往是更好的选择。 使用小写的函数名：CMake 的函数和宏的名字可以定义为大写或小写，但是一般都使用小写，变量名用大写。 使用 cmake_policy 和/或 限定版本号范围：每次改变版本特性 (policy) 都要有据可依。应该只有不得不使用旧特性时才降低特性 (policy) 版本。 ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:11:2","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["CMake"],"content":"参考 Communication with your code 在 CMakeLists.txt 中添加源文件的几种方法 CMake - 使用 target_sources() 提高源文件处理能力 Using AddressSanitizer (ASan) in a CMake project unsigned char and signed char cmake：这样查看源码的预编译信息 The GDB developer’s GNU Debugger tutorial, Part 1: Getting started with the debugger 使用 Gcov 和 LCOV 度量 C/C++ 项目的代码覆盖率 Linux 下 gcovr 的使用细节 Building with CMake Presets 使用 CMake Presets CMake Presets Organizing CMake presets Understanding RPATH (With CMake) 链接选项 rpath 的应用和原理 RPATH 简介以及 CMake 中的处理 rpath 使用说明 【ToolChains】| CMake 技巧 LLVM 之 Clang 静态分析器篇（1）：如何使用 Clang 静态分析器 CMake 行为准则 (Do’s and Don’ts) ","date":"2023-08-09","objectID":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/:12:0","tags":["C++","CMake"],"title":"CMake 构建项目","uri":"/cmake-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["Unit Testing"],"content":"1. 基本概念 单元测试是针对软件设计的最小单位进行测试，这里的最小单位可以是函数、模块或者类。目的是检查每个程序单元能否正确实现详细设计说明中的模块功能、性能、接口和设计约束等要求，发现各模块内部可能存在的各种错误。单元测试一般在宿主机中运行[4]。 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:1:0","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"1.0 单元 什么是单元，要不要从最小单元开测，不同人的观点都不相同。 笼统的说法：单元测试是针对软件设计的最小单位进行测试，这里的最小单位可以是函数、模块或者类。 《单元测试的艺术》 《Google 软件工程》 什么是 “公共 API “并不总是很清楚，这个问题实际上涉及到单元测试中的 “单元\"的核心。单元可以小到一个单独的函数，也可以大到由几个相关的包/模块组成的集合。当我们在这里说 “公共 API\"时，我们实际上是在谈论该单元暴露给拥有该代码的团队之外的第三方的 API。 对代码实现细节进行调用的测试是脆弱的，几乎任何对被测系统的重构（例如重命名其方法、将其分解为辅助类或更改序列化格式）都会导致测试中断，即使此类更改对类的实际用户是不可见的。 因此不要进行粒度过小的“白盒测试”，可能写出的是重复已有代码逻辑的无效测试。通过 Public 接口以及通过功能或场景测试，测试代码可维护性更高。 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:1:1","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"1.1 单元测试名词 断言（Assertions） 是检查条件是否为真的语句。断言的结果可能是成功或者失败，而失败又分为非致命失败或致命失败。如果发生致命失败，测试进程将中止当前运行，否则它将继续运行。类似函数调用的宏。 一般包含： bool 判断 逻辑运算判断 字符串判断 浮点数判断 异常判断 测试（Test） 使用断言来验证被测试代码的行为。如果测试崩溃或断言失败，则测试失败；否则测试成功。 测试套件（Test Suite） 包含一个或多个测试（Test）。当测试套件中的多个测试需要共享通用对象和子例程时，可以将它们放入测试夹具（Test Fixture）。 测试夹具 多个共有的数据配置的测试群 (包括初始化 Setup、运行 Run、验证结果 validate、清理 TearDown 四个过程) TAP 测试任意协议（Test Anything Protocol，TAP）是一种用于记录和报告测试结果的文本协议。它是一种轻量级的标准，旨在为不同编程语言的测试框架提供一种通用的格式，使测试结果能够被解析和分析，从而方便自动化测试的执行和报告。 通用性：TAP 不限于特定的编程语言或测试框架，因此可以用于多种语言的测试。因此，可以使用 TAP 来记录 Perl、Python、Ruby、C、Java 等各种语言的测试结果。 简洁的格式：TAP 使用简单的文本格式，易于阅读和理解。每个测试用例都表示为一行文本，其中包含测试结果、测试说明和其他信息。 易于解析：TAP 的格式易于解析，可以使用脚本或工具来分析测试输出并生成有关测试结果的报告。这种特性使 TAP 在自动化测试流程中特别有用。 丰富的测试结果表示：TAP 可以表示测试成功、失败、跳过、计划的测试数量等。 参数化框架 参数化测试是软件测试中的一种方法，它允许你在单个测试用例中运行多组测试数据，以便更全面地验证代码的不同输入情况。参数化测试框架是为了简化参数化测试的实现而设计的工具或库，它可以自动化地运行相同测试逻辑的不同参数组合，从而减少重复代码的编写，提高测试效率，并且更易于维护。 一般情况下，参数化测试框架主要用于在相同测试逻辑下，对不同的输入数据进行测试。如果不同的测试数据需要调用不同的函数，并且这些函数的参数类型和数量都不同，那么通常参数化测试框架可能无法直接满足这种需求。 参数化测试框架在运行时会根据预定义的参数组合，调用同一个测试函数，并传递不同的参数值。这个测试函数通常是事先定义好的，而且参数类型和数量是固定的。如果你需要在不同的测试数据情况下调用不同的函数，并且这些函数的参数类型和数量都不同，可能需要考虑其他的测试组织方式。 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:1:2","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"1.2 双目标开发 目标设备 宿主机（首要） 目标机上的测试会花费更长的时间和成本，基于宿主机的测试代价较小，先在软件代码层面排除所有问题。避免同时修改硬件和软件 bug，防止硬件部和软件部相互扯皮。并且能更容易移植到其他平台[1]。 定时问题有关的中断测试、硬件接口测试只能在目标机运行，在开发周期中处于靠后位置[4]。 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:1:3","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"1.3 Mock 在进行单元测试时，我们想要测试模块 A，但是模块 A 却依赖于模块 B，当模块 B 无法满足预期时就无法对模块 A 进行测试，主要由于下面几个原因： 模块 B 依赖于硬件设备 真实的模块 B 的返回值无法满足我们的预期 团队开发中模块 B 尚未实现 如何比较方便的控制模块 B 的行为，返回特定数据 这时就需要对函数 B 进行打桩，使其达到我们预期的效果。 生成测试桩方式： 返回固定值 模拟真实的下层模块（虚拟机之类） 仿制对象（mock） 开发一个测试桩的工作量和开发一个实际的模块的工作量是相当的[1]。一般开发中选择第三种 Mock 是为了解决不同的单元之间由于耦合而难于开发、测试的问题，Mock 既能出现在单元测试中，也会出现在集成测试、系统测试过程中。Mock 最大的功能是帮你把单元测试的耦合分解开，如果你的代码对另一个类或者接口有依赖，它能够帮你模拟这些依赖，并帮你验证所调用的依赖的行为。 Fake、Stub 和 Mock 的区别： 伪对象、桩对象、模拟对象 | 单元测试 Fake 译作伪对象，生产环境下具体实现的简化版本的对象，可以指 Stub 也可以指 Mock。 Stub 译作测试桩或存根，在当前测试用例的指示下返回某些值。 Mock 译作仿制对象或模拟对象，校验函数调用、调用顺序，以及从被测试代码传向依赖组建的参数，还可以设定向被测代码返回指定的值，常用于处理有多个复杂交互的场景。 三者概念不必做严格区分。 对 C 语言进行 mock 的三种方法：函数指针、预处理时期条件编译替换、编译后 Link 替换[5]。 三种测试方法分别对应的场景[3]： 所以最好在一开始选择支持 Mock 对象的测试框架。 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:1:4","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"2. 需求预估 Unit Test 硬件对象模拟（mock），并且由于我们有 HAL 层，更容易做到隔离 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:2:0","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"3. 通用工具 代码覆盖率工具 gcovr / lcov —— linux github CMake codecov OpenCppCoverage —— windows 不建议将覆盖率作为衡量代码质量的指标，如果使用 TDD 方式或者少写断言，自然能获得高覆盖。建议使用类似 [bug 数量]/千行 的指标衡量代码质量。 代码复杂度分析 (圈复杂度) lizard 静态检查类工具 cppcheck splint clang-tidy flawfinder 代码格式化 clang-format ctest CTest 是 CMake 集成的一个测试工具，在使用 CMakeLists.txt 文件编译工程的时候，CTest 会自动 configure、build、test 和展现测试结果。能执行一些简单测试，并集成 python 和 shell 脚本。 enable_testing()，测试这个目录和所有子文件夹。 add_test()，定义了一个新的测试，并设置测试名称和运行命令。 在使用测试框架的情况下，这个选项不是必须开启的，但是当测试框架产生的可执行文件较多时，CTest 可以执行批量测试并展示结果。 git hooks 服务器端自动执行测试，持续集成工具 脚本生成测试项目，使用 TUI 程序选择模块测试，类似编译 linux kernal 时的 menuconfig 脚本生成 CMake + Unity 项目 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:3:0","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"4. C 框架对比 名称 on mcu 参考 \u0026 使用 维护 行业 mock 易用性 结果 CppUTest ☑️ 🔥🔥 博世、AWS ✅ ✅ gtest ☑️ 🔥🔥🔥 Google ✅ ✅ Unity ✅ 🔥🔥 ✅ ✅ cmocka ☑️ 🔥 小米 ✅ ✅ CUnit ✅ 🔥 criterion ✅ libcester ☑️ ❌ ✅ cutest ✅ ❌ ❌ cgreen ✅ PARASOFT C/C++TEST 商业软件 GNU Autounit ❌ ❌ EmbeddedUnit ✅ ❌ ❌ Cmockery ❌ ❌ ❌ AceUnit ✅ ❌ Check ❌ ☑️ 表示能运行在性能较强的嵌入式平台 (包含操作系统)； ✅ 表示能运行在性能较差的嵌入式平台 完整列表在此处 已经删除一些过于小众的测试框架。 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:4:0","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"5. C 框架简单例子 使用 cmake 方式，使用不同框架，统一做一个 CRC 函数的校验测试。 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:5:0","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"5.1 CppUTest CppUTest 官方 CppUTest 是一个基于 C/C++ 的单元 xUnit 测试框架，用于单元测试和代码测试驱动。它是用 C++ 编写的，但在 C 和 C++ 项目中使用，在嵌入式测试中经常使用，但它适用于任何 C/C++ 项目。 为什么使用 C++ 框架测试 C？ 标准的 C 无法处理测试用例自安装问题，容易造成测试丢失[1]。 C++ 支持 C/C++ 测试，只使用有限的 C++ 语言特性。 特点： 指针恢复机制 支持 mock IEEE754 浮点数异常检测 内存泄漏检测 提示 Cpputest 仓库中有 ruby 脚本文件，能将测试的 cpp 文件转为 unity 测试用文件。 qpc STM32 arm-eabi-gcc mock RTOS ✅ ✅ ✅ ✅ ✅ 安装： sudo apt-get install cpputest 项目结构，用于测试嵌入式项目时，src作为源码目录存放.c文件，tests中存放测试框架的.cpp文件，基本所有测试框架都可以按照这个方式组织。 cmake_proj ├── CMakeLists.txt ├── src │ ├── CMakeLists.txt │ ├── code.c # 模板自带，添加多项式拟合函数 │ ├── code.h │ ├── crc.c # 添加 CRC 校验函数 │ ├── crc.h │ └── main.c └── tests ├── CMakeLists.txt ├── codeTest.cpp # 测试多项式拟合 ├── crc_test.cpp # 测试crc └── main.cpp tests/main.cpp 测试框架 main 函数 #include \"CppUTest/CommandLineTestRunner.h\" int main(int ac, char** av) { // CommandLineTestRunner 类名 return CommandLineTestRunner::RunAllTests(ac, av); } tests/codeTest.cpp 被测函数/模块 需要使用 extern \"C\" 引入模块的头文件 #include \"CppUTest/TestHarness.h\" extern \"C\" { #include \"code.h\" } TEST_GROUP(AwesomeExamples) { }; TEST(AwesomeExamples, FirstExample) { int x = test_func(); CHECK_EQUAL(1, x); } src/code.c #include \"code.h\" int test_func () { return 1; } src/code.h #ifndef __code_h__ #define __code_h__ int test_func (); #endif src/main.c #include \u003cstdio.h\u003e #include \"code.h\" int main(void) { test_func(); printf(\"hello world!\\n\"); exit(0); } 新增 polyfit.c polyfit.h，在 codeTest.cpp 中加入： #include \u003cCppUTest/CommandLineTestRunner.h\u003e #include \u003cCppUTest/TestHarness.h\u003e #include \u003cCppUTestExt/MockSupport.h\u003e extern \"C\" { #include \"code.h\" #include \"polyfit.h\" } TEST_GROUP(AwesomeExamples) { }; TEST(AwesomeExamples, FirstExample) { int x = test_func(); CHECK_EQUAL(1, x); } TEST_GROUP(TestPolyfit) { void setup() {} void teardown() { mock().clear(); } }; //---------------------------------------------------- // Testing Third Order Polynomial fitting... //-------------------------------------------------- TEST(TestPolyfit, ThirdOrderPoly) { const unsigned int order = 3; const unsigned int countOfElements = 5; const double acceptableError = 0.01; int result; // These inputs should result in the following approximate coefficients: // 0.5 2.5 1.0 3.0 // y = (0.5 * x^3) + (2.5 * x^2) + (1.0 * x) + 3.0 double xData[countOfElements] = { 12.0, 77.8, 44.1, 23.6, 108.2}; double yData[countOfElements] = { 1239.00, 250668.38, 47792.19, 7991.13, 662740.98}; double coefficients[order + 1]; // resulting array of coefs // Perform the polyfit result = polyfit(xData, yData, countOfElements, order, coefficients); CHECK_EQUAL(0, result); DOUBLES_EQUAL(0.5, coefficients[3], acceptableError); DOUBLES_EQUAL(2.5, coefficients[2], acceptableError); DOUBLES_EQUAL(1.0, coefficients[1], acceptableError); DOUBLES_EQUAL(3.0, coefficients[0], acceptableError); } //---------------------------------------------------- // Verify incorrect result - insufficient count of xData // and yData for the specified polyfit order. //-------------------------------------------------- TEST(TestPolyfit, InsufficientInputData) { const unsigned int order = 3; const unsigned int countOfElements = 2; int result; // These inputs should result in the following approximate coefficients: // 0.1 -3.2 -0.1 40.0 // y = (0.1 * x^3) + (-3.2 * x^2) + (-0.1 * x) + 40.0 double xData[countOfElements] = { 15.0, 77.0}; double yData[countOfElements] = { -344.0, 26712.8}; double coefficients[order + 1]; // resulting array of coefs // Perform the polyfit result = polyfit(xData, yData, countOfElements, order, coefficients); CHECK_EQUAL(-1, result); } 新增 crc.c 和 crc.h 文件： const uint16_t crc_table[256] = { #include \"crc_table.inc\" }; const uint16_t INIT = 0xffff; uint16_t CalculateCRC(uint8_t* message, size_t length) { uint16_t crc = INIT; uint16_t table_index; for (uint16_t i = 0; i \u003c length; i++) { table_index = ((crc \u003e\u003e 8) ^ message[i]) \u0026 0xff; crc = (uint16_t)((crc \u003c\u003c 8) ^ crc_table[table_index]); } return crc; } 进行了上述拟合多项式测试和 CRC 校验测试，输出情况： 测试成功时输出最少，重点显示测试失败的位置，行数。 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:5:1","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"5.2 Unity Unity 是一个用 C 语言构建的单元测试框架，专注于嵌入式领域。 Unity github 状态机 STM32 arm-eabi-gcc mock RTOS ✅ ✅ ✅ ✅ ✅ 项目结构： . ├── CMakeLists.txt ├── include │ └── example │ ├── crc.h │ └── example.h ├── src │ ├── CMakeLists.txt │ ├── example # 被测模块 │ │ ├── crc.c │ │ ├── crc_table.inc │ │ └── example.c │ └── main.c └── test ├── CMakeLists.txt ├── example │ ├── crc_test.c # crc 测试模块 │ └── main_test.c # 测试部分主函数 └── lib └── Unity # Unity 源码 其中 unity 包含在 tests 目录的 lib 中，以第三方库的形式集成在项目中。被测试模块 Example_lib 编译成库给测试模块使用。 使用 Unity 的 fixture 和 memory 功能时，要打开 Unity 目录下 CMakeLists.txt 文件的两个选项。 # Options to Build With Extras ------------------------------------------------- option(UNITY_EXTENSION_FIXTURE \"Compiles Unity with the \\\"fixture\\\" extension.\" ON) option(UNITY_EXTENSION_MEMORY \"Compiles Unity with the \\\"memory\\\" extension.\" ON) 测试模块函数 tests/crc_test.c #include \"unity_fixture.h\" #include \"example/crc.h\" TEST_GROUP(CRC) ; TEST_SETUP(CRC) { } TEST_TEAR_DOWN(CRC) { } // CRC 组测试 1 TEST(CRC, known_crc) { uint8_t message1[] = {0xaa, 0xde, 0xad, 0xbe, 0xef}; uint8_t message2[] = {0x0b, 0xb9, 0x7f, 0x4c, 0x4a, 0x32, 0xe6, 0x6b, 0x5e, 0xef, 0x86, 0xb1, 0xc2, 0x4b, 0x31}; uint16_t crc1 = CalculateCRC(message1, sizeof(message1)); uint16_t crc2 = CalculateCRC(message2, sizeof(message2)); TEST_ASSERT_EQUAL_UINT16(0xC149, crc1); TEST_ASSERT_EQUAL_UINT16(0x5BEE, crc2); } // CRC 组测试 2 TEST(CRC, Nonzero_output) { uint8_t message[] = {0x00, 0x00, 0x00, 0x00}; uint16_t crc = CalculateCRC(message, sizeof(message)); TEST_ASSERT_TRUE(crc != 0); } // CRC 组测试 3 TEST(CRC, Long_message) { uint8_t message[4096]; uint16_t crc; for (int i = 0; i \u003c sizeof(message); i++) { message[i] = i % 256; } crc = CalculateCRC(message, sizeof(message)); } // 定义本组哪些测试运行 TEST_GROUP_RUNNER(CRC) { RUN_TEST_CASE(CRC, known_crc); RUN_TEST_CASE(CRC, Nonzero_output); RUN_TEST_CASE(CRC, Long_message); } 相比以 C++ 为基础的测试框架，Unity 看起来断言种类要更多，比如判断整数相等会分为 8，16，32 位，有无符号等。猜测由于 C++ 支持函数重载和泛型编程等特性导致。 tests/main_test.c #include \"unity_fixture.h\" static void runAllTests() { RUN_TEST_GROUP(CRC); } int main(int argc, const char * argv[]) { return UnityMain(argc, argv, runAllTests); } 在 build 目录中执行： cmake --graphviz=foo.dot .. dot -T png foo.dot -o foo.png 可以生成项目依赖关系图： 进行了 CRC 校验测试，输出情况： 基本和 cpputest 一致。 教学 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:5:2","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"5.3 Gtest 最常见的单元测试框架，Google 开发，功能最多，多用于 C++ 项目测试。新版本 gtest 和 gmock 已经合并。 使用源码编译安装，编译前需要打开 gmock 下 cmake 文件的编译选项。 wget https://github.com/google/googletest/archive/refs/tags/v1.14.0.tar.gz tar -zxf v1.14.0.tar.gz cd googletest-release-1.14.1 mkdir build \u0026\u0026 cd build cmake .. make sudo make install 头文件安装在 /usr/local/include/gtest/ 库文件安装在 /usr/local/lib/ 下面是 CRC 校验测试项目结构： . ├── CMakeLists.txt ├── build ├── src │ ├── CMakeLists.txt │ ├── crc.c │ ├── crc.h │ ├── crc_table.inc │ └── main.c └── tests ├── CMakeLists.txt └── crc_test.cpp 使用方式和前两者基本相同，main() 函数所在文件： #include \u003cgtest/gtest.h\u003e extern \"C\" { #include \"crc.h\" } TEST(CRC, known_crc) { uint8_t message1[] = {0xaa, 0xde, 0xad, 0xbe, 0xef}; uint8_t message2[] = {0x0b, 0xb9, 0x7f, 0x4c, 0x4a, 0x32, 0xe6, 0x6b, 0x5e, 0xef, 0x86, 0xb1, 0xc2, 0x4b, 0x31}; uint16_t crc1 = CalculateCRC(message1, sizeof(message1)); uint16_t crc2 = CalculateCRC(message2, sizeof(message2)); EXPECT_EQ(0xC149, crc1); EXPECT_EQ(0x5BEE, crc2); } TEST(CRC, Nonzero_output) { uint8_t message[] = {0x00, 0x00, 0x00, 0x00}; uint16_t crc = CalculateCRC(message, sizeof(message)); EXPECT_TRUE(crc != 0); } TEST(CRC, Long_message) { uint8_t message[4096]; uint16_t crc; for (int i = 0; i \u003c int(sizeof(message)); i++) { message[i] = i % 256; } crc = CalculateCRC(message, sizeof(message)); EXPECT_EQ(0x1f5, crc); //EXPECT_EQ(0x1fb5, crc); } int main(int argc, char **argv) { printf(\"Running main() from %s\\n\", __FILE__); testing::InitGoogleTest(\u0026argc, argv); return RUN_ALL_TESTS(); } 输出： ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:5:3","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"5.4 cmocka cmocka, C 单元测试框架，支持 mock。只依赖 C 标准库，由 C 语言开发。 API: 注意 Misra 规则 Rule21.4 必然无法在单元测试中被满足，所有框架的底层都依赖头文件 setjmp.h 项目模板： cmocka 单元测试模板 可以以此为基准构建测试项目： command action make test_cppcheck check source code with cppcheck make compile source code executable can be found under build/src/ cmake .. generate buildsystem make doc generate documentation to view open build/doc/html/index.html make clean remove compiled files make tests run all tests cmocka \u0026 cppcheck make test_cmocka run cmocka tests 项目框架： . ├── build ├── CMakeLists.txt ├── doc │ ├── CMakeLists.txt │ └── Doxyfile.in ├── lib │ └── CMakeLists.txt ├── src │ ├── CMakeLists.txt │ ├── main.c │ └── mylib │ ├── CMakeLists.txt │ ├── crc.c │ ├── crc.h │ ├── crc_table.inc │ ├── mylib.c │ └── mylib.h └── test ├── CMakeLists.txt ├── mylib.c └── test.h 测试函数使用相对前三者较复杂，需要手动将测试函数添加到主函数的编组。 /***优先包含这几项***/ #include \u003cstdarg.h\u003e #include \u003cstddef.h\u003e #include \u003csetjmp.h\u003e // 可能违反 Misra Rule 21.4 #include \u003cstdint.h\u003e /***否则无法通过编译***/ #include \u003ccmocka.h\u003e //... static void says_hello(void **state) { (void)state; char str[10]; mylib_sayHello(str); assert_string_equal(\"Hello\", str); } static void crc_kownc(void **state) { (void)state; uint8_t message1[] = {0xaa, 0xde, 0xad, 0xbe, 0xef}; uint8_t message2[] = {0x0b, 0xb9, 0x7f, 0x4c, 0x4a, 0x32, 0xe6, 0x6b, 0x5e, 0xef, 0x86, 0xb1, 0xc2, 0x4b, 0x31}; uint16_t crc1 = CalculateCRC(message1, sizeof(message1)); uint16_t crc2 = CalculateCRC(message2, sizeof(message2)); assert_uint_equal(0xC149, crc1); assert_uint_equal(0x5BEE, crc2); } static void Nonzero_output(void **state) { (void)state; uint8_t message[] = {0x00, 0x00, 0x00, 0x00}; uint16_t crc = CalculateCRC(message, sizeof(message)); assert_true(crc != 0); } static void Long_message(void **state) { (void)state; uint8_t message[4096]; uint16_t crc; for (int i = 0; i \u003c (int)(sizeof(message)); i++) { message[i] = i % 256; } crc = CalculateCRC(message, sizeof(message)); assert_uint_equal(0x1f5, crc); //TEST_ASSERT_EQUAL_UINT16(0x1fb5, crc); } int main(void) { const struct CMUnitTest tests_mylib[] = { cmocka_unit_test(says_hello), cmocka_unit_test(crc_kownc), cmocka_unit_test(Nonzero_output), cmocka_unit_test(Long_message), }; return cmocka_run_group_tests(tests_mylib, NULL, NULL); } 输出内容和 goolgetest 类似，两者都是 google 开发的： ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:5:4","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"5.5 CUnit 其他框架主函数部分基本不用改动，相比之下 CUnit 使用不便捷，虽然能以列表的方式输出结果。 main()函数部分： #include ... int main() { CU_pSuite pSuite = NULL; //初始化 CUnit 注册表 if(CUE_SUCCESS != CU_initialize_registry()) return CU_get_error(); //向 CUnit 注册表添加单元 pSuite = CU_add_suite(\"Suite_1\", init_suite1, clean_suite1); if(NULL == pSuite) { CU_cleanup_registry(); //清空注册表，释放内存 return CU_get_error(); //返回错误 } //向单元添加测试用例 if((NULL == CU_add_test(pSuite, \"test of fprintf()\", testFPRINTF)) || (NULL == CU_add_test(pSuite, \"test of fread()\", testFREAD))) { CU_cleanup_registry(); return CU_get_error(); } //使用 CUnit Basic 接口运行所有测试单元 CU_basic_set_mode(CU_BRM_VERBOSE); CU_basic_run_tests(); CU_cleanup_registry(); return CU_get_error(); } ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:5:5","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"5.6 Criterion 特点： 自动注册测试 不需要声明 main 函数 测试过程隔离 hook 机制跟踪统计 使用便捷性好，但是不支持 mock 是主要问题。 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:5:6","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"5.7 Mock 全网关于单元测试的内容远大于 mock 相关内容。 5.7.1 Gmock 用 gmock 模拟 C 函数接口需要将其重写到一个类中，并且写成虚函数[2]。 官方：Mocking Free Functions 5.7.2 CppUTest 5.7.3 CMock 和 Unity 同一作者写的 mock 框架。但案例很少。 5.7.4 cmocka cmocka 相关资料很少 cmocka 5.7.5 其他独立的 mock 库 fff cpp-stub 参考回答： 嵌入式设备测试问题 描述了一个嵌入式设备测试问题，解决方案是使用一大一小两个框架，部署前主要在 PC 上进行测试，使用 Gtest 或者 CppUTest，实体设备使用 minunit(只有一个头文件，300 多行)。 Unit Testing Frameworks for C: Comparison ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:5:7","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"6. 测试用例设计 不要追求 100% 的用例覆盖，或者指望 UT 能查出所有 bug，应该把 UT 作为一种控制代码质量手段，通过 bug 完善用例。 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:6:0","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"6.1 测试数据 基于需求的测试 正面 / 负面测试 边界值分析 决策表 等效类划分 基于状态的测试 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:6:1","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"6.2 测试用例表 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:6:2","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"7. 其他 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:7:0","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"7. 1 qemu 官方的 qemu 不支持所有的 STM32 模拟功能，类似的开源项目只针对特定型号进行过二次开发。 官方： STMicroelectronics STM32 boards (netduino2, netduinoplus2, stm32vldiscovery) — QEMU documentation 非官方： GitHub - beckus/qemu_stm32: QEMU with an STM32 microcontroller implementation ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:7:1","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"7. 2 测试用例生成 allpairspy 参数组合测试工具 from allpairspy import AllPairs parameters = [ [\"Brand X\", \"Brand Y\"], [\"98\", \"NT\", \"2000\", \"XP\"], [\"Internal\", \"Modem\"], [\"Salaried\", \"Hourly\", \"Part-Time\", \"Contr.\"], [6, 10, 15, 30, 60], ] print(\"PAIRWISE:\") for i, pairs in enumerate(AllPairs(parameters)): print(\"{:2d}: {}\".format(i, pairs)) [1]. allpairspy KLEE 基于苹果 LLVM 的开源测试样例检测工具。需要 clang 编译环境，可运行在 docker 中。 [1]. KLEE_为复杂系统程序自动生成高覆盖率的测试 [2]. KLEE Symbolic Execution Engine 生成 ASN1 测试用例，模拟恶意数据 商业工具 Parasoft C/C++test Tessy Monkey 测试 Monkey是一个 Android 设备（模拟器或真实设备）上的一个程序，可以产生大量随机的用户输入事件，如点击、触摸、手势等。因此 Monkey 可用于 UI 上的压力测试。 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:7:2","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"7. 3 主要参考书 [1]. 测试驱动的嵌入式 C 语言开发 [2]. 软件单元测试入门与实践 [3]. C 现代编程 [4]. 嵌入式软件测试 [5]. 代码修改的艺术 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:7:3","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["Unit Testing"],"content":"7.4 参考 从零搭建一个 c/c++ 工程 - 将 gtest 引入到项目中 unit test mocking 详解圈复杂度 ","date":"2023-08-06","objectID":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/:7:4","tags":["Unit Testing","C"],"title":"单元测试框架","uri":"/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"categories":["其他"],"content":"需要安装的包 安装命令： install.packages('ggplot2', repos = 'https://mirrors.tuna.tsinghua.edu.cn/CRAN') readxl gridExtra ggsci ggpubr ","date":"2022-06-01","objectID":"/r-%E8%AF%AD%E8%A8%80%E7%BB%98%E5%9B%BE/:1:0","tags":["其他","R"],"title":"R 语言绘图","uri":"/r-%E8%AF%AD%E8%A8%80%E7%BB%98%E5%9B%BE/"},{"categories":["其他"],"content":"散点图绘制 如果需要绘制多组散点图，可以先把数据放在一个 excel 表中，整体导入数据框。每列数据名称最好不要使用中文。 library(ggplot2) library(readxl) df \u003c- read_xlsx(\"data.xlsx\") p \u003c- ggplot(df) + geom_point(aes(x = Vol1, y = Disp1), color=\"#5D567E\") + geom_point(aes(x = Vol2, y = Disp2), color=\"#C25E6C\") + labs(x=\"vol\",y=\"disp\",title=\"compare\") 效果： 颜色选择可以访问 colorspace 网站使用生成的配色。 ","date":"2022-06-01","objectID":"/r-%E8%AF%AD%E8%A8%80%E7%BB%98%E5%9B%BE/:2:0","tags":["其他","R"],"title":"R 语言绘图","uri":"/r-%E8%AF%AD%E8%A8%80%E7%BB%98%E5%9B%BE/"},{"categories":["项目"],"content":"1. 说明 学校老师希望能实现一个自动处理行程码、健康码信息的程序，本文记录一下实现过程。笔者非计算机专业人员，代码看看就好哈 😥。 ","date":"2022-04-13","objectID":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/:1:0","tags":["python","项目"],"title":"批量提取行程码/健康码信息到表格","uri":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/"},{"categories":["项目"],"content":"2. 实现思路 程序执行逻辑： 学生的行程码/健康码截图由管理人员汇总，全部保存到文件夹。 遍历文件夹，通过文件名分别处理行程码和健康码。 对于行程码，调用 OCR API 获取行程码信息，获取服务器 json 字符串，解析 json 处理结果。 对于健康码，使用二维码相关的包得到轮廓坐标，计算截取部分的颜色。 将结果对应保存到表格中。 ","date":"2022-04-13","objectID":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/:2:0","tags":["python","项目"],"title":"批量提取行程码/健康码信息到表格","uri":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/"},{"categories":["项目"],"content":"3. 健康码处理 健康码本身解析后是一个网页链接，普通人并不能获取持码人个人信息，只能考虑直接识别颜色。 ","date":"2022-04-13","objectID":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/:3:0","tags":["python","项目"],"title":"批量提取行程码/健康码信息到表格","uri":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/"},{"categories":["项目"],"content":"3.1 读取文件 考虑到收上来的截图会以中文来命名，但是 opencv 无法直接读取中文文件名的图片，需要借助 numpy 模块。 def cv_imread(file_path): cv_img = cv2.imdecode(np.fromfile(file_path, dtype=np.uint8), cv2.IMREAD_COLOR) return cv_img ","date":"2022-04-13","objectID":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/:3:1","tags":["python","项目"],"title":"批量提取行程码/健康码信息到表格","uri":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/"},{"categories":["项目"],"content":"3.2 二维码处理 Python 中用于处理二维码的包有：pyzbar、opencv-python 和 zxing。在实际使用过程中，pyzbar 无法很好处理黄码，zxing 表现较好，但是 zxing 本身由 java 实现，最后使用打包工具生成的 exe 无法运行。最后选择了 opencv-python 中的 QRCodeDetector 模块，实现了获取二维码轮廓坐标的功能。 def scan_qrcode(image): qrCodeDetector = cv2.QRCodeDetector() decodedText, points, _ = qrCodeDetector.detectAndDecode(image) return decodedText, points 拿到 points 坐标后可以直接截取出来这个部分用于下一步识别颜色。 ","date":"2022-04-13","objectID":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/:3:2","tags":["python","项目"],"title":"批量提取行程码/健康码信息到表格","uri":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/"},{"categories":["项目"],"content":"3.3 颜色识别 定义 HSV 颜色范围 # 颜色范围定义 color_dist = { 'red': {'Lower': np.array([0, 60, 60]), 'Upper': np.array([6, 255, 255])}, 'blue': {'Lower': np.array([100, 80, 46]), 'Upper': np.array([124, 255, 255])}, 'green': {'Lower': np.array([35, 43, 35]), 'Upper': np.array([90, 255, 255])}, 'yellow': {'Lower': np.array([26, 43, 46]), 'Upper': np.array([34, 255, 255])}, } def detect_color(image, color): gs = cv2.GaussianBlur(image, (5, 5), 0) hsv = cv2.cvtColor(gs, cv2.COLOR_BGR2HSV) mask = cv2.inRange(hsv, color_dist[color]['Lower'], color_dist[color]['Upper']) image_s = image.shape[0] * image.shape[1] ratio = sum(sum(mask // 255)) / image_s if ratio \u003e 0.02: return True else: return False ","date":"2022-04-13","objectID":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/:3:3","tags":["python","项目"],"title":"批量提取行程码/健康码信息到表格","uri":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/"},{"categories":["项目"],"content":"4. 处理行程码 从行程码截图提取出的信息和健康码信息并无重合，所以无法通过图片信息进行匹配。只能依赖上传时的命名。 这里直接使用百度智能云的 API 获取行程码信息。先注册百度智能云账号，获取 API Key 和 Secret Key。将行程码用 base64 编码后传给服务器，解析获取的 json 字符串，提取手机号码 (不全)、途径地、风险等级和更新时间。 ","date":"2022-04-13","objectID":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/:4:0","tags":["python","项目"],"title":"批量提取行程码/健康码信息到表格","uri":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/"},{"categories":["项目"],"content":"5. 生成表格 使用 xlwt 模块生成表格，用当天日期命名。 import datetime ... xl = xlwt.Workbook(encoding='utf-8') sheet = xl.add_sheet('sheet1', cell_overwrite_ok=True) sheet.write(0, 0, '姓名') sheet.write(0, 1, '手机号码') sheet.write(0, 2, '途径地') sheet.write(0, 3, '风险等级') sheet.write(0, 4, '行程码更新时间') sheet.write(0, 5, '健康码颜色') now = datetime.datetime.now() excel_name = now.strftime('%Y-%m-%d') + '.xls' ","date":"2022-04-13","objectID":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/:5:0","tags":["python","项目"],"title":"批量提取行程码/健康码信息到表格","uri":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/"},{"categories":["项目"],"content":"6. 打包 将 python 程序打包成 exe 文件一般使用 pyinstaller 包，让程序能够在无 python 环境的机器上也能运行。假设现在为 main.py 进行打包。 pip3 install pyinstaller 然后进入项目目录，执行命令： pyinstaller -F main.py 错误 1: The 'typing' package is an obsolete backport of a standard library package and is incompatible with PyInstaller. Please `conda remove typing` then try again. 直接 conda remove typing 会很慢并有可能不成功。可以运行 pip uninstall typing。 错误 2: PermissionError: [Errno 13] Permission denied: xxx 将 main.py 文件所在目录的属性选项中的 只读 选项去掉，然后再执行命令。 错误 3: TypeError: _get_sysconfigdata_name() missing 1 required positional argument: 'check_exists' 参考文末链接 4 的解决方法。 最后在路径下生成的文件夹中找到 dist 文件夹，将其中的 main.exe 文件移动到项目目录下，双击打开即可运行。main.py 文件，dist 等文件夹都可以删除。 如需自定义图标并不显示控制台，使用命令： Pyinstaller -F -w -i xx.ico main.py ","date":"2022-04-13","objectID":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/:6:0","tags":["python","项目"],"title":"批量提取行程码/健康码信息到表格","uri":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/"},{"categories":["项目"],"content":"参考 stackoverflow typing error Python 报错：PermissionError: [Errno 13] Permission denied 别再问我怎么 Python 打包成 exe 了！ 使用 pyinstaller 将 py 文件打包成 exe 注意事项及报错 ","date":"2022-04-13","objectID":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/:7:0","tags":["python","项目"],"title":"批量提取行程码/健康码信息到表格","uri":"/%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96%E8%A1%8C%E7%A8%8B%E7%A0%81%E4%BF%A1%E6%81%AF%E5%88%B0%E8%A1%A8%E6%A0%BC/"},{"categories":["C++"],"content":"1. 说明 笔者项目中使用 halcon 图像处理软件导出的 C++ 代码组织工程。为测试 halcon 部分算法的效果，需要对图像序列进行处理，且需要查看数据的形状。在 C++ 中不依赖图形框架直接绘图可以使用 matplotlib-cpp 来实现。在此记录一种最快的方法。 ","date":"2022-04-08","objectID":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/:1:0","tags":["C++","图像处理","Python"],"title":"Matplotlib Cpp C++ 中使用 Python 绘图模块的方法","uri":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["C++"],"content":"2. 过程 ","date":"2022-04-08","objectID":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/:2:0","tags":["C++","图像处理","Python"],"title":"Matplotlib Cpp C++ 中使用 Python 绘图模块的方法","uri":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["C++"],"content":"2.1 安装必要的包 首先需要 python 环境，并且安装 matplotlib 和 numpy。 下一步安装 vcpkg 作为 C++ 的包管理器。 git clone https://github.com/microsoft/vcpkg cd vcpkg .\\bootstrap-vcpkg.bat .\\vcpkg integrate install 执行完毕后，vcpkg 就被集成到了 VS2022 中。 ","date":"2022-04-08","objectID":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/:2:1","tags":["C++","图像处理","Python"],"title":"Matplotlib Cpp C++ 中使用 Python 绘图模块的方法","uri":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["C++"],"content":"2.2 安装 matplotlib-cpp .\\vcpkg install matplotlib-cpp .\\vcpkg install matplotlib-cpp:x64-windows 没有报错后可进行下一步。 ","date":"2022-04-08","objectID":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/:2:2","tags":["C++","图像处理","Python"],"title":"Matplotlib Cpp C++ 中使用 Python 绘图模块的方法","uri":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["C++"],"content":"2.3 配置 VS2022 添加附加包含目录 打开项目 –\u003e 属性。 在 C++ –\u003e 常规 中添加本地 python 的 include 文件夹路径和 numpy 的 include 路径。 添加附加库目录 在 链接器 –\u003e 常规 中添加 python libs 路径。 input 在 链接器 –\u003e 输入 中添加 python 的 lib 文件。 修改 matplotcpp.h 文件 打开 matplotlib-cpp.h 文件，在头文件中添加 include \u003cstring\u003e。不然会报\"命名空间 std 没有成员 stod\"的错误。 关于这个错误，我查看项目的 github 仓库，源文件中已经添加了 string 头文件，但通过 vcpkg 安装的版本仍需添加。 注释掉 340 行左右的两个 template 定义。 ","date":"2022-04-08","objectID":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/:2:3","tags":["C++","图像处理","Python"],"title":"Matplotlib Cpp C++ 中使用 Python 绘图模块的方法","uri":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["C++"],"content":"3. 运行效果 计算图像序列的锐度值后绘制图像，观察尖峰性。使用时只需要添加头文件和命名空间， #include \"matplotlibcpp.h\" namespace plt = matplotlibcpp; 把想要查看的向量传入 plot 即可。结果如下： ","date":"2022-04-08","objectID":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/:3:0","tags":["C++","图像处理","Python"],"title":"Matplotlib Cpp C++ 中使用 Python 绘图模块的方法","uri":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["C++"],"content":"参考 VisualStudio2019 c++ 安装 matplotlib-cpp 【C++】11 Visual Studio 2019 C++ 安装 matplotlib-cpp 绘图 ","date":"2022-04-08","objectID":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/:4:0","tags":["C++","图像处理","Python"],"title":"Matplotlib Cpp C++ 中使用 Python 绘图模块的方法","uri":"/matplotlib-cpp-c-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E7%BB%98%E5%9B%BE%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["C++"],"content":"1. 说明 项目需要对比 opencv 和 halcon 在某些算法执行上的速度。记录一下编译 opencv cuda 版本的流程。 ","date":"2022-04-07","objectID":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:1:0","tags":["opencv","cuda","C++"],"title":"Opencv Cuda 版本编译流程","uri":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"},{"categories":["C++"],"content":"2. 工具 opencv cuda 版本的编译需要各种工具版本相互配合。以下组合是在我在 windows 11 上编译成功使用的组合。(OpenCV 4.4 替换成新版本的 3.4 也可) CMake 3.18 CUDA Toolkit 11.0 Visual Studio 2022 OpenCV 4.4 \u0026 OpenCV_contrib 4.4 ","date":"2022-04-07","objectID":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:2:0","tags":["opencv","cuda","C++"],"title":"Opencv Cuda 版本编译流程","uri":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"},{"categories":["C++"],"content":"3. 编译流程 ","date":"2022-04-07","objectID":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:3:0","tags":["opencv","cuda","C++"],"title":"Opencv Cuda 版本编译流程","uri":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"},{"categories":["C++"],"content":"3.1 CUDA 安装 CUDA11 和 对应的 CUDNN，并配置环境变量。 ","date":"2022-04-07","objectID":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:3:1","tags":["opencv","cuda","C++"],"title":"Opencv Cuda 版本编译流程","uri":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"},{"categories":["C++"],"content":"3.2 CMake 将 OpenCV_contrib 4.4 和 OpenCV 4.4 分别解压。打开 CMake-gui 设置源码目录和目标目录。 点击“Configure”按钮。生成选项后，勾选/取消勾选相关内容： 打开 WITH_TBB 勾选和 CUDA 相关选项 取消选择 java 和 python 的编译选项 (个人不需要) 勾选 nonfree 的编译选项 取消 TEST 相关选项加快编译速度 勾选 BUILD_opencv_world 最终只生成一个动态链接库方便使用 在 OPENCV_EXTRA_MODULES_PATH 中填入 OpenCV_contrib 解压文件夹 modules 的路径 取消选择 OPENCV_GENERATE_SETUPVARS 再次点击 configure 按钮，由于网络问题会出现无法下载的错误，可以取消勾选 face 模块，然后再次点击 configure 按钮。使用 OpenCV4.5 时这一步多出很多下载错误，取消勾选 face 还有很多，所以换回了 4.4 版本。然后勾选 CUDA_FAST_MATH 点 configure 按钮。 要保证生成 CMakeLists.txt 过程中不出现红色警告，不然后续的编译过程会出现错误。 无错误后点击 Generate 按钮，生成 Opencv.sln 文件。 ","date":"2022-04-07","objectID":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:3:2","tags":["opencv","cuda","C++"],"title":"Opencv Cuda 版本编译流程","uri":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"},{"categories":["C++"],"content":"3.3 VS2022 打开生成的 OpenCV.sln 文件，找到项目 ALL_BUILD，分别在 Debug 和 Release 下右击生成。编译大概需要六个小时。可以使用批生成功能。 ALL_BUILD 完成后，找到项目 INSTALL 右击生成。最终会在当前 build 目录下生成一个 install 目录，这就是我们需要的可执行文件和库，最后添加到环境变量中测试效果。 ","date":"2022-04-07","objectID":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:4:0","tags":["opencv","cuda","C++"],"title":"Opencv Cuda 版本编译流程","uri":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"},{"categories":["C++"],"content":"4. 效果 将 install 目录中的 bin 目录添加到环境变量中，推荐使用环境变量管理工具 rapid environment editor。 bin 文件在 install/x64/vc16 中： 打开项目属性 VC++ 目录，分别设置 包含目录： 库目录： 在 链接器 –\u003e 输入 –\u003e 附加依赖项 中，分别在 debug 和 release 模式下添加 opencv_world3415d.lib、opencv_world3415.lib 至此配置完毕。 添加头文件，即可开始使用 cuda. #include \u003copencv2/core/cuda.hpp\u003e int main() { cuda::printCudaDeviceInfo(cuda::getDevice()); int count = cuda::getCudaEnabledDeviceCount(); printf(\"GPU Device Count : %d\\n\", count); printf(\"OpenCV version: %s\\n\", CV_VERSION); } ","date":"2022-04-07","objectID":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:5:0","tags":["opencv","cuda","C++"],"title":"Opencv Cuda 版本编译流程","uri":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"},{"categories":["C++"],"content":"参考 Win10 使用 VS2019 从源码编译 OpenCV 4.4 + CUDA 11.0 + Cudnn 8.0 + python3 OpenCV + CUDA 开发 - 编译与环境配置 ","date":"2022-04-07","objectID":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:6:0","tags":["opencv","cuda","C++"],"title":"Opencv Cuda 版本编译流程","uri":"/opencv-cuda-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"},{"categories":["C++"],"content":"1. 说明 本文是阅读知乎网友教程 如何用 C++ 实现一个简易数据库 的笔记。 ","date":"2022-03-18","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/:1:0","tags":["C++","数据库"],"title":"[未完成] C++ 简单数据库系统","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"},{"categories":["C++"],"content":"Rspec 一种基于 Ruby 的测试框架，可以用来测试 C++ 程序输出是否符合预期。 describe XXX do it XXX do ...... end end 结构体偏移 #include \u003cstddef.h\u003e size_t offsetof(type, member); `` 宏定义： ```cpp #define size_of_attribute(Struct, Attribute) sizeof(((Struct *)0)-\u003eAttribute) 序列化:把对象转化为可传输的字节序列过程称为序列化。 反序列化：把字节序列还原为对象的过程称为反序列化。 序列化的目的是为了对象可以跨平台存储，和进行网络传输。 ","date":"2022-03-18","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/:2:0","tags":["C++","数据库"],"title":"[未完成] C++ 简单数据库系统","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"},{"categories":["C++"],"content":"1. 说明 学校课题组祖传代码缺乏日志系统，监控过程信息非常麻烦，想自己实现一个简易的 Log 模块实现基本 Log 功能，顺带学习单例模式。代码参考自网络公开的博客和教程，并给出了链接。 ","date":"2022-03-14","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/:1:0","tags":["C++","友元","单例模式"],"title":"[未完成] C++ 简单 Log","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/"},{"categories":["C++"],"content":"2. 日志级别 项目本身要求不是很高，只考虑实现 info, warning, error 三个等级的日志信息。 ","date":"2022-03-14","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/:2:0","tags":["C++","友元","单例模式"],"title":"[未完成] C++ 简单 Log","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/"},{"categories":["C++"],"content":"3. 日志功能 获取时间 输出信息到日志文件或终端 ","date":"2022-03-14","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/:3:0","tags":["C++","友元","单例模式"],"title":"[未完成] C++ 简单 Log","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/"},{"categories":["C++"],"content":"4. 普通方法实现 ","date":"2022-03-14","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/:4:0","tags":["C++","友元","单例模式"],"title":"[未完成] C++ 简单 Log","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/"},{"categories":["C++"],"content":"4.1 时间获取 std::string getCurrentTime() { const time_t now = time(nullptr); char str[26]; ctime_s(str, sizeof str, \u0026now); return str; } ","date":"2022-03-14","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/:4:1","tags":["C++","友元","单例模式"],"title":"[未完成] C++ 简单 Log","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/"},{"categories":["C++"],"content":"4.2 logger 类 class Log { public: const int LogLevelError = 0; const int LogLevelWaring = 1; const int LogLevelInfo = 2; private: int m_LogLevel = LogLevelInfo; // 默认 public: void SetLevel(int level) { m_LogLevel = level; } void Error(const char* message) { if (m_LogLevel \u003e= LogLevelError) std::cout \u003c\u003c getCurrentTime() \u003c\u003c \"[Error]:\" \u003c\u003c message \u003c\u003c std::endl; } void Warning(const char* message) { if (m_LogLevel \u003e= LogLevelWaring) std::cout \u003c\u003c getCurrentTime() \u003c\u003c \"[Warning]:\" \u003c\u003c message \u003c\u003c std::endl; } void Info(const char* message) { if (m_LogLevel \u003e= LogLevelInfo) std::cout \u003c\u003c getCurrentTime() \u003c\u003c \"[information]:\" \u003c\u003c message \u003c\u003c std::endl; } }; int main() { Log log; log.SetLevel(log.LogLevelWaring); log.Warning(\"Warning\"); log.Error(\"Error\"); log.Info(\"info\"); } ","date":"2022-03-14","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/:4:2","tags":["C++","友元","单例模式"],"title":"[未完成] C++ 简单 Log","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/"},{"categories":["C++"],"content":"5. 单例模式 设计需求：某个类只需要一个实例化对象。 典型场景： 系统日志由一个日志管理器记录； 线程池； 全局游戏的窗口； 要求： 将构造函数非 public; 使用一个静态成员函数保存唯一实例； 实现一个 public 方法，获取唯一实例； 禁用移动构造和拷贝构造； class Singleton { public: static Singleton\u0026 GetInstance() { static Singleton inst; return inst; } Singleton(const Singleton\u0026) = delete; Singleton\u0026 operator = (const Singleton\u0026) = delete; // ... private: Singleton() { // ... } // ... }; 参考陈硕老师 muduo 库中的 noncopyable 类，构造单例模式禁用拷贝构造和赋值操作时可以继承一个 noncopyable 类，对于阅读代码的人更友好。 class noncopyable { public: noncopyable(const noncopyable\u0026) = delete; void operator=(const noncopyable\u0026) = delete; protected: noncopyable() = default; ~noncopyable() = default; }; ","date":"2022-03-14","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/:5:0","tags":["C++","友元","单例模式"],"title":"[未完成] C++ 简单 Log","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/"},{"categories":["C++"],"content":"参考 C++ 新标准 004_不简单的“单例模式” ","date":"2022-03-14","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/:6:0","tags":["C++","友元","单例模式"],"title":"[未完成] C++ 简单 Log","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/c++-%E7%AE%80%E5%8D%95-log/"},{"categories":["项目"],"content":"1. json 格式 一种数据交换格式，源于 JavaScript，可用于任何编程语言。 json 是树状结构，包含六种类型： null; boolean number string array object 任务要求： 把 json 解析为一个树状结构 提供访问接口 把数据结构转换成 json 文本 头文件设计注意 include 防范，避免重复声明。 #ifndef LEPTJSON_H__ #define LEPTJSON_H__ /* ... */ #endif /* LEPTJSON_H__ */ 因为 C 语言没有 C++ 的命名空间（namespace）功能，一般会使用项目的简写作为标识符的前缀。通常枚举值用全大写（如 LEPT_NULL），而类型及函数则用小写（如 lept_type）。 在 cJSON 库中定义了如下结构体表示一个 json 数据： /* The cJSON structure: */ typedef struct cJSON { /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */ struct cJSON *next; struct cJSON *prev; /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */ struct cJSON *child; /* The type of the item, as above. */ int type; /* The item's string, if type==cJSON_String and type == cJSON_Raw */ char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */ int valueint; /* The item's number, if type==cJSON_Number */ double valuedouble; /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */ char *string; } cJSON; JSON 语法子集： JSON-text = ws value ws ws = *(%x20 / %x09 / %x0A / %x0D) value = null / false / true null = \"null\" false = \"false\" true = \"true\" 那么第一行的意思是，JSON 文本由 3 部分组成，首先是空白（whitespace），接着是一个值，最后是空白。 第二行告诉我们，所谓空白，是由零或多个空格符（space U+0020）、制表符（tab U+0009）、换行符（LF U+000A）、回车符（CR U+000D）所组成。 第三行是说，我们现时的值只可以是 null、false 或 true，它们分别有对应的字面值（literal）。 ","date":"2022-02-13","objectID":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/cjson-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/:1:0","tags":["C"],"title":"[未完成] Cjson 解析器的简单实现","uri":"/draft/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/cjson-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"},{"categories":["嵌入式"],"content":"licheepi-zero 采用全志 V3s 芯片，是一款小型的 Linux 开发板。官方提供了镜像可以直接使用 Win32DiskImager 烧录，也可以根据需要自己制作。和大多嵌入式 Linux 系统一样主要分为 uboot 系统引导，linux 内核以及根文件系统三个部分。本文主要记录制作过程中可能遇到的问题和教程中缺失的部分。 ","date":"2022-02-12","objectID":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/:0:0","tags":["嵌入式","Linux","Licheepi"],"title":"Licheepi Zero 镜像制作流程","uri":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"1. 前期准备 知识： Linux 常用命令 Makefile 的基本概念 设备： usb-ttl 模块 licheepi-zero 开发板 sd 卡 4.3 寸通用屏 linux 系统 (实体机或者虚拟机，用于编译和烧录 SD 卡) 工具链： 交叉编译器 arm-linux-gnueabihf wget https://releases.linaro.org/components/toolchain/binaries/latest/arm-linux-gnueabihf/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf.tar.xz 解压后放到某处，并在 zshrc 或者 bashrc 中添加环境变量。 export PATH=$PATH:/usr/local/arm/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin 编译过程中依赖的包 sudo apt install git wget make gcc g++ flex bison libssl-dev bc kmod automake autoconf libtool sudo apt installl linux-headers-$(uname -r) sudo apt installl libncurses5-dev sudo apt-get install device-tree-compiler sudo apt-get install patch cpio unzip rsync Python 2 环境 实际使用过程中发现，在编译根文件系统时会用到系统的 Python，并且是 Python2 脚本，所以需要确保系统的环境变量 python 指向的是 python2.7。 ","date":"2022-02-12","objectID":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/:1:0","tags":["嵌入式","Linux","Licheepi"],"title":"Licheepi Zero 镜像制作流程","uri":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"2. 编译系统 ","date":"2022-02-12","objectID":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/:2:0","tags":["嵌入式","Linux","Licheepi"],"title":"Licheepi Zero 镜像制作流程","uri":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"2.1 uboot uboot 中相关的配置有 Soc 架构、DDR、LCD、时钟和 SPL 等，详细内容和参看官方文档。 下载 uboot: git clone https://github.com/Lichee-Pi/u-boot.git -b v3s-current 此时需要修改配置文件，使 u-boot 可以直接从 tf 卡启动，在 u-boot 目录的 include/configs/sun8i.h 文件中添加 #define CONFIG_BOOTCOMMAND \"setenv bootm_boot_mode sec; \" \\ \"load mmc 0:1 0x41000000 zImage; \" \\ \"load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-dock.dtb; \" \\ \"bootz 0x41000000 - 0x41800000;\" #define CONFIG_BOOTARGS \"console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw vt.global_cursor_default=0\" 编译 (这里使用 4.3 寸屏幕): make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_480x272LCD_defconfig make ARCH=arm menuconfig time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 2\u003e\u00261 | tee build.log 编译完成后结果在当前目录，文件名 u-boot-sunxi-with-spl.bin。 ","date":"2022-02-12","objectID":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/:2:1","tags":["嵌入式","Linux","Licheepi"],"title":"Licheepi Zero 镜像制作流程","uri":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"2.2 kernel 下一步编译 Linux 内核，首先下载： git clone -b zero-5.2.y --depth 1 https://github.com/Lichee-Pi/linux.git 进入 Linux 文件夹，修改 Makefile 文件，找到 364 行写入： [364]ARCH = arm [365]CROSS_COMPILE = arm-linux-gnueabihf- [366]INSTALL_MOD_PATH = out 开始编译： make licheepi_zero_defconfig make menuconfig make -j4 make dtbs 完成后 zImage 文件在arch/arm/boot/下，设备树在arch/arm/ boot/dts下。 首次编译一般都会遇到如下问题： /usr/bin/ld: scripts/dtc/dtc-parser.tab.o:(.bss+0x20): multiple definition of `yylloc'; scripts/dtc/dtc-lexer.lex.o:(.bss+0x0): first defined here collect2: error: ld returned 1 exit status make[1]: *** [scripts/Makefile.host:99: scripts/dtc/dtc] Error 1 需要对源文件修改几处： vim scripts/dtc/dtc-parser.tab.h 修改extern XXX yylloc 为yyloc vim scripts/dtc/dtc-lexer.l 修改XXX yylloc 为 extern XXX yylloc ","date":"2022-02-12","objectID":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/:2:2","tags":["嵌入式","Linux","Licheepi"],"title":"Licheepi Zero 镜像制作流程","uri":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"2.3 rootfs 下载 buildroot： wget https://buildroot.org/downloads/buildroot-2017.08.tar.gz 配置根文件系统： make menuconfig 比较重要的包括： 配置文件保存位置 外部工具链 C library hostname Root password Target package(常用软件库) 在选择常用软件库时，部分库需要在 configmenu 中选中 C++ 支持才能选中，例如 Qt。 直接使用 make 命令编译。编译过程中会联网下载选中的包，部分托管在 github 等境外服务器的包可能会遇到网络问题。此时可暂停编译，复制当前下载包的地址，通过 ghproxy 代理手动下载到 dl 目录下，再执行编译将自动检测到目标。 编译完成后会在 output/images 下生成 rootfs.tar。 ","date":"2022-02-12","objectID":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/:2:3","tags":["嵌入式","Linux","Licheepi"],"title":"Licheepi Zero 镜像制作流程","uri":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"3. 镜像制作 ","date":"2022-02-12","objectID":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/:3:0","tags":["嵌入式","Linux","Licheepi"],"title":"Licheepi Zero 镜像制作流程","uri":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"3.1 SD 卡分区和挂载 在 Linux 安装 Gparted 图形化分区工具。 sudo apt install gparted 通过 ls /dev/sd* 命令查看当前插入 sd 卡名称。 将 SD 卡原本的分区删掉，建立一个 32M FAT16 格式 (或 FAT32) 的分区存放引导文件和系统镜像，用剩余部分建立 ext4 格式分区。 重新插拔 SD 卡，需要确认两个分区是否挂载成功： df -h 实际使用过程中，一般两个分区无法同时自动挂载成功。 如果存在未被挂载的情况需要手动挂载，首先创建挂载文件夹 BOOT 和 rootfs(一般在 /media 或者 /mnt 下)，然后使用mount命令挂载 (umount 取消挂载）: sudo mount /dev/sda1 /media/mufasa/BOOT sudo mount /dev/sda2 /media/mufasa/rootfs ","date":"2022-02-12","objectID":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/:3:1","tags":["嵌入式","Linux","Licheepi"],"title":"Licheepi Zero 镜像制作流程","uri":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"3.2 复制文件 将四个文件 rootfs.tar，sun8i-v3s-licheepi-zero-dock.dtb，u-boot-sunxi-with-spl.bin，zImage 复制到同一文件夹中。 使用 dd 命令将 uboot 文件写到 8k 位置 (规定) sudo dd if=u-boot-sunxi-with-spl.bin of=/dev/sdx bs=1024 seek=8 将 dtb 和 zImage 拷贝到 fat16 分区。 cp sun8i-v3s-licheepi-zero-dock.dtb /media/mufasa-/BOOT/ cp zImage /media/mufasa/BOOT/ 根文件系统解压到 ext4 分区 sudo tar xvf rootfs.tar -C /media/mufasa/rootfs/ 默认使能串口登录，需要修改 /etc/inittab : #console::respawn:/sbin/getty -L console 0 vt100 # GENERIC_SERIAL ttyS0::respawn:/sbin/getty -L ttyS0 115200 vt100 # GE 需要免密码登录，直接 #console::respawn:/sbin/getty -L console 0 vt100 # GENERIC_SERIAL ttyS0::respawn:/bin/sh ","date":"2022-02-12","objectID":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/:3:2","tags":["嵌入式","Linux","Licheepi"],"title":"Licheepi Zero 镜像制作流程","uri":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"4. 效果 打开 MobaXterm 新建一个串口会话，波特率 115200。使用杜邦线按照如下方式连接开发板和 usb-ttl 模块： usb-ttl --\u003e 开发板引脚 3.3V --\u003e 供电 GND --\u003e GND RX --\u003e TX(U0) TX --\u003e RX(U0) 打开串口后能看到屏幕被点亮，并通过电脑串口能够登录和操作开发板。 ","date":"2022-02-12","objectID":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/:4:0","tags":["嵌入式","Linux","Licheepi"],"title":"Licheepi Zero 镜像制作流程","uri":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"5. 参考链接 licheepi 官方文档 荔枝派 Zero V3s 开发板入坑记录 荔枝派 zero 镜像制作及烧录 ","date":"2022-02-12","objectID":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/:5:0","tags":["嵌入式","Linux","Licheepi"],"title":"Licheepi Zero 镜像制作流程","uri":"/licheepi-zero-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["C++"],"content":"1. 预编译头文件 将头文件编译成中间格式，从而节省在开发过程中编译器从头编译造成的开销。 一般预编译头文件中的头文件是标准库，操作系统 API 或者无需修改的开发框架，通过预编译减少编译时间。 在 Vistual Studio 中，项目模板的预编译头文件是 pch.h或stdafx.h。项目文件夹下生成的ipch文件夹是存放预编译头结果的地方，故上传 github 时可直接忽略。 ","date":"2022-02-11","objectID":"/c-%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6/:1:0","tags":["C++"],"title":"C++ 预编译头文件","uri":"/c-%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"2. g++ 中使用预编译头 以一个简单项目为例： src | -- main.cpp | -- pch,h | -- pch.cpp // pch.h 文件内容 #pragma once #include \u003ciostream\u003e #include \u003cfunctional\u003e #include \u003calgorithm\u003e #include \u003cutility\u003e #include \u003cstack\u003e #include \u003cdeque\u003e #include \u003cstring\u003e #include \u003cvector\u003e #include \u003cunordered_map\u003e 在不使用预编译头的情况下测试： time g++ -std=c++11 main.cpp 使用预编译头，需要先生成中间文件 g++ -std=c++11 pch.h 之后会生成pch.h.gch文件 再执行编译，得到： ","date":"2022-02-11","objectID":"/c-%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6/:2:0","tags":["C++"],"title":"C++ 预编译头文件","uri":"/c-%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"3. 在 Vistual Studio 中使用预编译头 还是针对以上项目。选中想要创建预编译头的 pch.cpp 文件，右键属性 –\u003e C/C++ –\u003e 预编译头 –\u003e 创建。 然后配置整个项目的属性 –\u003e C/C++ –\u003e 预编译头 –\u003e 使用。 这样，经过第一次编译后，在之后的开发过程中能极大减少编译时间。 ","date":"2022-02-11","objectID":"/c-%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6/:3:0","tags":["C++"],"title":"C++ 预编译头文件","uri":"/c-%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"4. CMake 中使用预编译头 此功能在 CMake 3.16 版本之后被支持。在 CMake 中使用预编译头需要使用 target_precompile_headers 命令。假设有一个 main.cpp 和一个 mypch.h 的预编译头文件。 // mypch.h #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cvector\u003e 那么 CMake 文件： cmake_minimum_required(VERSION 3.16) project(PrecompiledHeadersExample) add_executable(MyApp main.cpp) # 指定预编译头文件 target_precompile_headers(MyApp PRIVATE mypch.h) 对于 C 和 C++ 混合项目，最好单独编译成不同的库或者可执行文件，不要出现 add_executable 阶段 .cpp 和 .c 一块儿被编译的情况。这会导致 CMake 无法正确处理预编译头。 ","date":"2022-02-11","objectID":"/c-%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6/:4:0","tags":["C++"],"title":"C++ 预编译头文件","uri":"/c-%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"1. 项目任务 学习跳表结构 使用跳表实现 KV 存储 实现接口： insert_element 插入数据 delete_element 删除数据 search_element 查询数据 update_element 更新数据 display_list 打印跳跃表 dump_file 数据落盘 load_file 加载数据 size 返回数据规模 clear 清空跳表 关键词： 跳跃表、C++ 模板 ","date":"2022-02-07","objectID":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84-kv-%E5%AD%98%E5%82%A8/:1:0","tags":["C++","模板"],"title":"[未完成] 基于跳表的 KV 存储","uri":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84-kv-%E5%AD%98%E5%82%A8/"},{"categories":["C++"],"content":"2. 跳表 跳表 ( SkipList，全称跳跃表) 是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。能提高搜索性能，同时也可以提高插入和删除操作的性能。 ","date":"2022-02-07","objectID":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84-kv-%E5%AD%98%E5%82%A8/:2:0","tags":["C++","模板"],"title":"[未完成] 基于跳表的 KV 存储","uri":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84-kv-%E5%AD%98%E5%82%A8/"},{"categories":["C++"],"content":"构造步骤 给定一个有序的链表。 选择连表中最大和最小的元素，然后从其他元素中按照一定算法（随机）随即选出一些元素，将这些元素组成有序链表。这个新的链表称为一层，原链表称为其下一层。 为刚选出的每个元素添加一个指针域，这个指针指向下一层中值同自己相等的元素。Top 指针指向该层首元素。 重复 2、3 步，直到不再能选择出除最大最小元素以外的元素。 ","date":"2022-02-07","objectID":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84-kv-%E5%AD%98%E5%82%A8/:2:1","tags":["C++","模板"],"title":"[未完成] 基于跳表的 KV 存储","uri":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84-kv-%E5%AD%98%E5%82%A8/"},{"categories":["C++"],"content":"参考链接 跳表实现 KV 存储 Skip List（跳跃表）原理详解与实现 跳表 (SkipList) 设计与实现 (Java) ","date":"2022-02-07","objectID":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84-kv-%E5%AD%98%E5%82%A8/:3:0","tags":["C++","模板"],"title":"[未完成] 基于跳表的 KV 存储","uri":"/draft/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84-kv-%E5%AD%98%E5%82%A8/"},{"categories":["Linux"],"content":"1. tty TTY，teletype 的缩写。 早期终端是一种电传打字机，并且最早终端和控制台不是一种东西。 数控设备的控制设备一般叫控制台，终端是通过串口连接上的，不是计算机本身的设备。能显示系统运行状态的叫控制台，其他叫终端。 但是发展到现在基本已经不区分二者的概念。终端渐渐发展成了一个软件概念。 现代计算机的 terminal 程序是运行在用户态的仿真程序，称为伪终端 (pty)。 ","date":"2022-01-04","objectID":"/draft/%E7%99%BE%E7%A7%91/linux-%E4%B8%8B%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E7%BC%A9%E5%86%99%E5%92%8C%E8%A7%A3%E9%87%8A/:1:0","tags":["Linux"],"title":"Linux 下名称缩写和解释","uri":"/draft/%E7%99%BE%E7%A7%91/linux-%E4%B8%8B%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E7%BC%A9%E5%86%99%E5%92%8C%E8%A7%A3%E9%87%8A/"},{"categories":["Linux"],"content":"2. console ","date":"2022-01-04","objectID":"/draft/%E7%99%BE%E7%A7%91/linux-%E4%B8%8B%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E7%BC%A9%E5%86%99%E5%92%8C%E8%A7%A3%E9%87%8A/:2:0","tags":["Linux"],"title":"Linux 下名称缩写和解释","uri":"/draft/%E7%99%BE%E7%A7%91/linux-%E4%B8%8B%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E7%BC%A9%E5%86%99%E5%92%8C%E8%A7%A3%E9%87%8A/"},{"categories":["Linux"],"content":"3. coredump 当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种过程被称为 Core Dump（核心转储）。 在半导体作为电脑内存材料之前，电脑内存使用的是磁芯内存（Magnetic Core Memory），Core Dump 中的 Core 沿用了磁芯内存的 Core 表达。 Dump 指的是拷贝一种存储介质中的部分内容到另一个存储介质，或者将内容打印、显示或者其它输出设备。dump 出来的内容是格式化的，可以使用一些工具来解析它。 ","date":"2022-01-04","objectID":"/draft/%E7%99%BE%E7%A7%91/linux-%E4%B8%8B%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E7%BC%A9%E5%86%99%E5%92%8C%E8%A7%A3%E9%87%8A/:3:0","tags":["Linux"],"title":"Linux 下名称缩写和解释","uri":"/draft/%E7%99%BE%E7%A7%91/linux-%E4%B8%8B%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E7%BC%A9%E5%86%99%E5%92%8C%E8%A7%A3%E9%87%8A/"},{"categories":["Linux"],"content":"4. usr ","date":"2022-01-04","objectID":"/draft/%E7%99%BE%E7%A7%91/linux-%E4%B8%8B%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E7%BC%A9%E5%86%99%E5%92%8C%E8%A7%A3%E9%87%8A/:4:0","tags":["Linux"],"title":"Linux 下名称缩写和解释","uri":"/draft/%E7%99%BE%E7%A7%91/linux-%E4%B8%8B%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E7%BC%A9%E5%86%99%E5%92%8C%E8%A7%A3%E9%87%8A/"},{"categories":["其他"],"content":"2024.05.07 更新 已修改迁移到 github，无需手动开通 Pages 服务，直接 push 到 github用户名.github.io 后即可访问网页。 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:1:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"1. 安装 通过应用商店下载 WSL，使用包管理器安装 Hugo 即可。 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:2:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"2. 创建项目 hugo new site mysite #项目名称 mysite 进入 mysite 目录，结构和功能如下： mysite ├── archetypes # markdown文章的模版 ├── config.toml # 配置文件 ├── content # 网站内容，主要保存文章 ├── data # 生成网站可用的数据文件，可用在模版中 ├── layouts # 生成网站时可用的模版 ├── public # 通过hugo命令生成的静态文件，主要发布这个 ├── resources # 通过hugo命令一起生成的资源文件 ├── static # 静态文件，比如文章中的图片/视频文件、缩略图等 └── themes # 存放hugo主题 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:3:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"3. 挑选主题 搜索 Hugo 主题，在主题网站挑选合适主题后，git clone 主题项目到路径 mysite/themes 下。 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:4:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"4. 根据主题文档进行操作 一般需要将主题提供的 config.toml 文件，按照作者提示编辑修改后，覆盖 hugo 初始默认的配置文件。 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:5:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"5. 编辑文章 hugo new posts/first.md 文章会被创建到目录 content/posts 下，使用 markdown 语法编辑。 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:6:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"6. markdown 部分语法 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:7:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"6.1 表格 设置表格对齐方式： 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:7:1","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"6.2 强调格式 方式 效果 *abc* abc **abc** abc ***abc*** abc ~~abc~~ abc ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:7:2","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"7. 启用 hugo server 查看效果 hugo server -D 点击链接能够在浏览器中查看效果。 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:8:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"8. 图像 配置文件的图像放在主题文件夹的 static 中 文章的图像放在根目录的 static 文件夹中，或者使用图床链接 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:9:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"9. gitee 配置 由于 github 访问问题，建议部署到 gitee 确保站点能被正常访问。 在 gitee 上新建一个仓库，仓库名称和 gitee 的用户名相同。生成的个人站点链接将会是gitee用户名.gitee.io 。 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:10:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"10. 编译 执行以下命令编译站点： hugo --theme=theme_name --baseURL=\"https://gitee用户名.gitee.io\" -D 能够看到在项目文件夹中生成了 public 文件夹。 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:11:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"11. 将 public 推到 gitee 仓库 cd public git init git add . git commit -m \"test\" git remote add origin '仓库地址' git push -u origin master ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:12:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"12. 在 gitee 仓库服务中开启 gitee pages 服务 点击服务 –\u003e Git pages，按照流程开通，点击部署。打开网页查看效果： ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:13:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"13. 后续维护 存放源码的仓库被托管到 github 后，themes 文件夹下的项目由于有 .git 目录，会被设置成子模块。clone 仓库到本地后需要下载主题到 theme 文件夹。 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者从一开始下载时就一同下载子模块 ​git clone --recursive https://github.com/xxx 再或者直接删除主题项目的 .git 目录，直接 push 所有文件到仓库。 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:14:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"参考 Hugo - 10 分钟搭建 \u0026 部署个人网站/博客，简历中的博客网站怎么建 Hugo + Markdown + MathJax Markdown 表格：对齐方式，表格内换行、加粗、斜体，合并单元格 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/:15:0","tags":null,"title":"使用 hugo 和 gitee 创建静态个人站点","uri":"/%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-gitee-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"},{"categories":["其他"],"content":"1. 在本地和虚拟机中都安装 OpenSSH sudo apt install openssh-server 测试是否安装 ssh ssh localhost ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/:1:0","tags":null,"title":"SSH 连接虚拟机","uri":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["其他"],"content":"2. 编辑本机 SSH config 文件打开默认端口 vim /etc/ssh/sshd_config ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/:2:0","tags":null,"title":"SSH 连接虚拟机","uri":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["其他"],"content":"3. 虚拟机设置 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/:3:0","tags":null,"title":"SSH 连接虚拟机","uri":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["其他"],"content":"网络地址转换 NAT 设置 –\u003e 网络 –\u003e 网络地址转换 –\u003e 高级 –\u003e 端口转发 –\u003e 添加规则 ： 名称可随便填写，如 ssh 主机 IP 可以不填，或者填写 127.0.0.1 主机端口随意填写一个不会产生冲突的端口，如 2222 子系统端口可以不填，或者填写子系统当前 IP 地址 子系统端口如果是要进行 ssh 连接，则填写 22；ftp 就填写 21 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/:3:1","tags":null,"title":"SSH 连接虚拟机","uri":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["其他"],"content":"4. 本地和虚拟机重启 ssh sudo /etc/init.d/ssh restart 其他： sudo /etc/init.d/ssh start #启动ssh服务 sudo /etc/init.d/ssh stop #停止ssh服务 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/:4:0","tags":null,"title":"SSH 连接虚拟机","uri":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["其他"],"content":"6. 连接 ssh -l [username] -p 1111 127.0.0.1 根据提示输入密码和用户名。结果： 输入exit可退出。 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/:5:0","tags":null,"title":"SSH 连接虚拟机","uri":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["其他"],"content":"参考 使用 ssh 连接 VirtualBox 虚拟机 Linux——本机终端 SSH 连接 VirtualBox 中的 Linux 虚拟机 ","date":"2021-12-29","objectID":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/:6:0","tags":null,"title":"SSH 连接虚拟机","uri":"/%E4%BD%BF%E7%94%A8-ssh-%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["git"],"content":"1. SSH 密钥 ","date":"2021-10-05","objectID":"/gitee-%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E4%BB%93%E5%BA%93/:1:0","tags":["git"],"title":"Gitee 使用问题","uri":"/gitee-%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E4%BB%93%E5%BA%93/"},{"categories":["git"],"content":"1.1 问题 使用 git push 时出现： git@gitee.com: Permission denied (publickey). fatal: 无法读取远程仓库。 请确认您有正确的访问权限并且仓库存在。 ","date":"2021-10-05","objectID":"/gitee-%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E4%BB%93%E5%BA%93/:1:1","tags":["git"],"title":"Gitee 使用问题","uri":"/gitee-%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E4%BB%93%E5%BA%93/"},{"categories":["git"],"content":"1.2 解决 对自己的邮箱，重新生成 SSH key ssh-keygen -t rsa -C \"XXX@XX.com\" 一直回车，得到类似： The key fingerprint is: SHA256:1jZz2AqNZQJNpWRf0miTxYU4EAmkT+Ip1P5lbZRqdN0 XXX@XX.com The key's randomart image is: +---[RSA 3072]----+ | .++*=oBoo. | | . . +ooB=+. | | . + . +.Bo. E | | . o = . % o | | . + . S X | | . . = + = | | . . | | | | | +----[SHA256]-----+ 查看生成的密钥 vim ~/.ssh/id_rsa.pub 复制密钥，添加到 gitee 终端输入： ssh -T git@gitee.com 出现： Hi kali_mufasa! You've successfully authenticated, ... 完成。后半句警告 “but GitHub does not provide shell access” 没有关系。 ","date":"2021-10-05","objectID":"/gitee-%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E4%BB%93%E5%BA%93/:1:2","tags":["git"],"title":"Gitee 使用问题","uri":"/gitee-%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E4%BB%93%E5%BA%93/"},{"categories":["git"],"content":"2. 避免用户名和密码的输入 首先查看当前连接情况 git remote -v 如果输出是 origin https://gitee.com/xxx/xxx.git (fetch) origin https://gitee.com/xxx/xxx.git (push) 说明使用的是 https 连接方式，需要反复输入用户名和密码，修改为 SSH 连接更安全。 git remote rm origin git remote add origin git@gitee.com:xxx/xxx.git ","date":"2021-10-05","objectID":"/gitee-%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E4%BB%93%E5%BA%93/:2:0","tags":["git"],"title":"Gitee 使用问题","uri":"/gitee-%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E4%BB%93%E5%BA%93/"}]